{
  "Questions": [
    {
      "title": "Combine Two Tables",
      "description": "Table: Person\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| PersonId    | int     |\n| FirstName   | varchar |\n| LastName    | varchar |\n+-------------+---------+\nPersonId is the primary key column for this table.\n\nTable: Address\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| AddressId   | int     |\n| PersonId    | int     |\n| City        | varchar |\n| State       | varchar |\n+-------------+---------+\nAddressId is the primary key column for this table.\n\nWrite a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people:\nFirstName, LastName, City, State",
      "example": "",
      "solution": "Approach: Using outer join [Accepted]\nAlgorithm\nSince the PersonId in table Address is the foreign key of table Person, we can join this two table to get the address information of a person.\nConsidering there might not be an address information for every person, we should use outer join instead of the default inner join.\nMySQL\nselect FirstName, LastName, City, State\nfrom Person left join Address\non Person.PersonId = Address.PersonId\n;",
      "Difficulty": "Easy",
      "extra": "extra information"
    },
    {
      "title": "Second Highest Salary",
      "description": "Write a SQL query to get the second highest salary from the Employee table.\n+----+--------+\n| Id | Salary |\n+----+--------+\n| 1  | 100    |\n| 2  | 200    |\n| 3  | 300    |\n+----+--------+\n\nFor example, given the above Employee table, the query should return 200 as the second highest salary. If there is no second highest salary, then the query should return null.\n+---------------------+\n| SecondHighestSalary |\n+---------------------+\n| 200                 |\n+---------------------+",
      "example": "",
      "solution": "Approach: Using sub-query and LIMIT clause [Accepted]\nAlgorithm\nSort the distinct salary in descend order and then utilize the LIMIT clause to get the second highest salary.\nSELECT DISTINCT\n    Salary AS SecondHighestSalary\nFROM\n    Employee\nORDER BY Salary DESC\nLIMIT 1 OFFSET 1\n\nHowever, this solution will be judged as 'Wrong Answer' if there is no such second highest salary since there might be only one record in this table. To overcome this issue, we can take this as a temp table.\nMySQL\nSELECT\n    (SELECT DISTINCT\n            Salary\n        FROM\n            Employee\n        ORDER BY Salary DESC\n        LIMIT 1 OFFSET 1) AS SecondHighestSalary\n;\n\nApproach: Using IFNULL and LIMIT clause [Accepted]\nAnother way to solve the 'NULL' problem is to use IFNULL funtion as below.\nMySQL\nSELECT\n    IFNULL(\n      (SELECT DISTINCT Salary\n       FROM Employee\n       ORDER BY Salary DESC\n        LIMIT 1 OFFSET 1),\n    NULL) AS SecondHighestSalary",
      "Difficulty": "Easy",
      "extra": ""
    },
    {
      "title": "Nth Highest Salary",
      "description": "Write a SQL query to get the nth highest salary from the Employee table.\n+----+--------+\n| Id | Salary |\n+----+--------+\n| 1  | 100    |\n| 2  | 200    |\n| 3  | 300    |\n+----+--------+\n\nFor example, given the above Employee table, the nth highest salary where n = 2 is 200. If there is no nth highest salary, then the query should return null.\n+------------------------+\n| getNthHighestSalary(2) |\n+------------------------+\n| 200                    |\n+------------------------+",
      "example": "",
      "solution": "CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT\nBEGIN\nDECLARE M INT;\nSET M=N-1;\n  RETURN (\n      # Write your MySQL query statement below.\n      SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT M, 1\n  );\nEND",
      "Difficulty": "Medium",
      "extra": ""
    },
    {
      "title": "Rank Scores",
      "description": "Write a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no \"holes\" between ranks.\n+----+-------+\n| Id | Score |\n+----+-------+\n| 1  | 3.50  |\n| 2  | 3.65  |\n| 3  | 4.00  |\n| 4  | 3.85  |\n| 5  | 4.00  |\n| 6  | 3.65  |\n+----+-------+\n\nFor example, given the above Scores table, your query should generate the following report (order by highest score):\n+-------+------+\n| Score | Rank |\n+-------+------+\n| 4.00  | 1    |\n| 4.00  | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.50  | 4    |\n+-------+------+",
      "example": "",
      "solution": "Simple, Short, Fast\nThese are four different solutions.\nWith Variables: 841 ms\nFirst one uses two variables, one for the current rank and one for the previous score.\nSELECT\n  Score,\n  @rank := @rank + (@prev <> (@prev := Score)) Rank\nFROM\n  Scores,\n  (SELECT @rank := 0, @prev := -1) init\nORDER BY Score desc\n\nAlways Count: 1322 ms\nThis one counts, for each score, the number of distinct greater or equal scores.\nSELECT\n  Score,\n  (SELECT count(distinct Score) FROM Scores WHERE Score >= s.Score) Rank\nFROM Scores s\nORDER BY Score desc\n\nAlways Count, Pre-uniqued: 795 ms\nSame as the previous one, but faster because I have a subquery that \"uniquifies\" the scores first. Not entirely sure why it's faster, I'm guessing MySQL makes tmp a temporary table and uses it for every outer Score.\nSELECT\n  Score,\n  (SELECT count(*) FROM (SELECT distinct Score s FROM Scores) tmp WHERE s >= Score) Rank\nFROM Scores\nORDER BY Score desc\n\nFilter/count Scores^2: 1414 ms\nInspired by the attempt in wangkan2001's answer. Finally Id is good for something :-)\nSELECT s.Score, count(distinct t.score) Rank\nFROM Scores s JOIN Scores t ON s.Score <= t.score\nGROUP BY s.Id\nORDER BY s.Score desc",
      "Difficulty": "Medium",
      "extra": ""
    },
    {
      "title": "Consecutive Numbers",
      "description": "Write a SQL query to find all numbers that appear at least three times consecutively.\n+----+-----+\n| Id | Num |\n+----+-----+\n| 1  |  1  |\n| 2  |  1  |\n| 3  |  1  |\n| 4  |  2  |\n| 5  |  1  |\n| 6  |  2  |\n| 7  |  2  |\n+----+-----+\n\nFor example, given the above Logs table, 1 is the only number that appears consecutively for at least three times.\n+-----------------+\n| ConsecutiveNums |\n+-----------------+\n| 1               |\n+-----------------+",
      "example": "",
      "solution": "Approach: Using DISTINCT and WHERE clause [Accepted]\nAlgorithm\nConsecutive appearing means the Id of the Num are next to each others. Since this problem asks for numbers appearing at least three times consecutively, we can use 3 aliases for this table Logs, and then check whether 3 consecutive numbers are all the same.\nSELECT *\nFROM\n    Logs l1,\n    Logs l2,\n    Logs l3\nWHERE\n    l1.Id = l2.Id - 1\n    AND l2.Id = l3.Id - 1\n    AND l1.Num = l2.Num\n    AND l2.Num = l3.Num\n;\n\nIdNumIdNumIdNum112131>Note: The first two columns are from l1, then the next two are from l2, and the last two are from l3.\nThen we can select any Num column from the above table to get the target data. However, we need to add a keyword DISTINCT because it will display a duplicated number if one number appears more than 3 times consecutively.\nMySQL\nSELECT DISTINCT\n    l1.Num AS ConsecutiveNums\nFROM\n    Logs l1,\n    Logs l2,\n    Logs l3\nWHERE\n    l1.Id = l2.Id - 1\n    AND l2.Id = l3.Id - 1\n    AND l1.Num = l2.Num\n    AND l2.Num = l3.Num\n;",
      "Difficulty": "Medium",
      "extra": ""
    },
    {
      "title": "Employees Earning More Than Their Managers",
      "description": "The Employee table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id.\n+----+-------+--------+-----------+\n| Id | Name  | Salary | ManagerId |\n+----+-------+--------+-----------+\n| 1  | Joe   | 70000  | 3         |\n| 2  | Henry | 80000  | 4         |\n| 3  | Sam   | 60000  | NULL      |\n| 4  | Max   | 90000  | NULL      |\n+----+-------+--------+-----------+\n\nGiven the Employee table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager.\n+----------+\n| Employee |\n+----------+\n| Joe      |\n+----------+\n\n",
      "example": "",
      "solution": "SolutionApproach I: Using WHERE clause [Accepted]\nAlgorithm\nAs this table has the employee's manager information, we probably need to select information from it twice.\nSELECT *\nFROM Employee AS a, Employee AS b\n;\n\nNote: The keyword 'AS' is optional.\nIdNameSalaryManagerIdIdNameSalaryManagerId1Joe7000031Joe7000032Henry8000041Joe7000033Sam600001Joe7000034Max900001Joe7000031Joe7000032Henry8000042Henry8000042Henry8000043Sam600002Henry8000044Max900002Henry8000041Joe7000033Sam600002Henry8000043Sam600003Sam600003Sam600004Max900003Sam600001Joe7000034Max900002Henry8000044Max900003Sam600004Max900004Max900004Max90000> The first 3 columns are from a and the last 3 ones are from b.\nSelect from two tables will get the Cartesian product of these two tables. In this case, the output will be 4*4 = 16 records. However, what we interest is the employee's salary higher than his/her manager. So we should add two conditions in a WHERE clause like below.\nSELECT\n    *\nFROM\n    Employee AS a,\n    Employee AS b\nWHERE\n    a.ManagerId = b.Id\n        AND a.Salary > b.Salary\n;\n\nIdNameSalaryManagerIdIdNameSalaryManagerId1Joe7000033Sam60000\nAs we only need to output the employee's name, so we modify the above code a little to get a solution.\nMySQL\nSELECT\n    a.Name AS 'Employee'\nFROM\n    Employee AS a,\n    Employee AS b\nWHERE\n    a.ManagerId = b.Id\n        AND a.Salary > b.Salary\n;\n\nApproach I: Using JOIN clause [Accepted]\nAlgorithm\nActually, JOIN is a more common and efficient way to link tables together, and we can use ON to specify some conditions.\nSELECT\n     a.NAME AS Employee\nFROM Employee AS a JOIN Employee AS b\n     ON a.ManagerId = b.Id\n     AND a.Salary > b.Salary\n;",
      "Difficulty": "Easy",
      "extra": ""
    },
    {
      "title": "Duplicate Emails",
      "description": "Write a SQL query to find all duplicate emails in a table named Person.\n+----+---------+\n| Id | Email   |\n+----+---------+\n| 1  | a@b.com |\n| 2  | c@d.com |\n| 3  | a@b.com |\n+----+---------+\n\nFor example, your query should return the following for the above table:\n+---------+\n| Email   |\n+---------+\n| a@b.com |\n+---------+",
      "example": "",
      "solution": "SolutionApproach I: Using GROUP BY and a temporary table [Accepted]\nAlgorithm\nDuplicated emails existed more than one time. To count the times each email exists, we can use the following code.\nselect Email, count(Email) as num\nfrom Person\ngroup by Email;\n\n| Email   | num |\n|---------|-----|\n| a@b.com | 2   |\n| c@d.com | 1   |\n\nTaking this as a temporary table, we can get a solution as below.\nselect Email from\n(\n  select Email, count(Email) as num\n  from Person\n  group by Email\n) as statistic\nwhere num > 1\n;\n\nApproach II: Using GROUP BY and HAVING condition [Accepted]\nA more common used way to add a condition to a GROUP BY is to use the HAVING clause, which is much simpler and more efficient.\nSo we can rewrite the above solution to this one.\nMySQL\nselect Email\nfrom Person\ngroup by Email\nhaving count(Email) > 1;",
      "Difficulty": "Easy",
      "extra": ""
    },
    {
      "title": "Customers Who Never Order",
      "description": "Suppose that a website contains two tables, the Customers table and the Orders table. Write a SQL query to find all customers who never order anything.\nTable: Customers.\n+----+-------+\n| Id | Name  |\n+----+-------+\n| 1  | Joe   |\n| 2  | Henry |\n| 3  | Sam   |\n| 4  | Max   |\n+----+-------+\n\nTable: Orders.\n+----+------------+\n| Id | CustomerId |\n+----+------------+\n| 1  | 3          |\n| 2  | 1          |\n+----+------------+\n\nUsing the above tables as example, return the following:\n+-----------+\n| Customers |\n+-----------+\n| Henry     |\n| Max       |\n+-----------+",
      "example": "",
      "solution": "Approach: Using sub-query and NOT IN clause [Accepted]\nAlgorithm\nIf we have a list of customers who have ever ordered, it will be easy to know who never ordered.\nWe can use the following code to get such list.\nselect customerid from orders;\n\nThen, we can use NOT IN to query the customers who are not in this list.\nMySQL\nselect customers.name as 'Customers'\nfrom customers\nwhere customers.id not in\n(\n    select customerid from orders\n);",
      "extra": "nothing",
      "Difficulty": "Easy"
    },
    {
      "title": "Department Highest Salary",
      "description": "The Employee table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id.\n+----+-------+--------+--------------+\n| Id | Name  | Salary | DepartmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 70000  | 1            |\n| 2  | Henry | 80000  | 2            |\n| 3  | Sam   | 60000  | 2            |\n| 4  | Max   | 90000  | 1            |\n+----+-------+--------+--------------+\n\nThe Department table holds all departments of the company.\n+----+----------+\n| Id | Name     |\n+----+----------+\n| 1  | IT       |\n| 2  | Sales    |\n+----+----------+\n\nWrite a SQL query to find employees who have the highest salary in each of the departments. For the above tables, Max has the highest salary in the IT department and Henry has the highest salary in the Sales department.\n+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Max      | 90000  |\n| Sales      | Henry    | 80000  |\n+------------+----------+--------+\n\n",
      "example": "",
      "solution": "SolutionApproach: Using JOIN and IN clause [Accepted]\nAlgorithm\nSince the Employee table contains the Salary and DepartmentId information, we can query the highest salary in a department.\nSELECT\n    DepartmentId, MAX(Salary)\nFROM\n    Employee\nGROUP BY DepartmentId;\n\nNote: There might be multiple employees having the same highest salary, so it is safe not to include the employee name information in this query.\n| DepartmentId | MAX(Salary) |\n|--------------|-------------|\n| 1            | 90000       |\n| 2            | 80000       |\n\nThen, we can join table Employee and Department, and query the (DepartmentId, Salary) are in the temp table using IN statement as below.\nMySQL\nSELECT\n    Department.name AS 'Department',\n    Employee.name AS 'Employee',\n    Salary\nFROM\n    Employee\n        JOIN\n    Department ON Employee.DepartmentId = Department.Id\nWHERE\n    (Employee.DepartmentId , Salary) IN\n    (   SELECT\n            DepartmentId, MAX(Salary)\n        FROM\n            Employee\n        GROUP BY DepartmentId\n    )\n;\n\n| Department | Employee | Salary |\n|------------|----------|--------|\n| Sales      | Henry    | 80000  |\n| IT         | Max      | 90000  |",
      "extra": "nothing",
      "Difficulty": "Medium"
    },
    {
      "title": "Department Top Three Salaries",
      "description": "The Employee table holds all employees. Every employee has an Id, and there is also a column for the department Id.\n+----+-------+--------+--------------+\n| Id | Name  | Salary | DepartmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 70000  | 1            |\n| 2  | Henry | 80000  | 2            |\n| 3  | Sam   | 60000  | 2            |\n| 4  | Max   | 90000  | 1            |\n| 5  | Janet | 69000  | 1            |\n| 6  | Randy | 85000  | 1            |\n+----+-------+--------+--------------+\n\nThe Department table holds all departments of the company.\n+----+----------+\n| Id | Name     |\n+----+----------+\n| 1  | IT       |\n| 2  | Sales    |\n+----+----------+\n\nWrite a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows.\n+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Max      | 90000  |\n| IT         | Randy    | 85000  |\n| IT         | Joe      | 70000  |\n| Sales      | Henry    | 80000  |\n| Sales      | Sam      | 60000  |\n+------------+----------+--------+",
      "example": "",
      "solution": "SolutionApproach: Using JOIN and sub-query [Accepted]\nAlgorithm\nA top 3 salary in this company means there is no more than 3 salary bigger than itself in the company.\nselect e1.Name as 'Employee', e1.Salary\nfrom Employee e1\nwhere 3 >\n(\n    select count(distinct e2.Salary)\n    from Employee e2\n    where e2.Salary > e1.Salary\n)\n;\n\nIn this code, we count the salary number of which is bigger than e1.Salary. So the output is as below for the sample data.\n| Employee | Salary |\n|----------|--------|\n| Henry    | 80000  |\n| Max      | 90000  |\n| Randy    | 85000  |\n\nThen, we need to join the Employee table with Department in order to retrieve the department information.\nMySQL\nSELECT\n    d.Name AS 'Department', e1.Name AS 'Employee', e1.Salary\nFROM\n    Employee e1\n        JOIN\n    Department d ON e1.DepartmentId = d.Id\nWHERE\n    3 > (SELECT\n            COUNT(DISTINCT e2.Salary)\n        FROM\n            Employee e2\n        WHERE\n            e2.Salary > e1.Salary\n                AND e1.DepartmentId = e2.DepartmentId\n        )\n;\n\n| Department | Employee | Salary ||------------|----------|--------|\n| IT         | Joe      | 70000  |\n| Sales      | Henry    | 80000  |\n| Sales      | Sam      | 60000  |\n| IT         | Max      | 90000  |\n| IT         | Randy    | 85000  |",
      "extra": "nothing",
      "Difficulty": "Hard"
    },
    {
      "title": "Delete Duplicate Emails",
      "description": "Write a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id.\n+----+------------------+\n| Id | Email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n| 3  | john@example.com |\n+----+------------------+\nId is the primary key column for this table.\n\nFor example, after running your query, the above Person table should have the following rows:\n+----+------------------+\n| Id | Email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n+----+------------------+\n\n",
      "example": "",
      "solution": "SolutionApproach: Using DELETE and WHERE clause [Accepted]\nAlgorithm\nBy joining this table with itself on the Email column, we can get the following code.\nSELECT p1.*\nFROM Person p1,\n    Person p2\nWHERE\n    p1.Email = p2.Email\n;\n\nThen we need to find the bigger id having same email address with other records. So we can add a new condition to the WHERE clause like this.\nSELECT p1.*\nFROM Person p1,\n    Person p2\nWHERE\n    p1.Email = p2.Email AND p1.Id > p2.Id\n;\n\nAs we already get the records to be deleted, we can alter this statement to DELETE in the end.\nMySQL\nDELETE p1 FROM Person p1,\n    Person p2\nWHERE\n    p1.Email = p2.Email AND p1.Id > p2.Id",
      "extra": "nothing",
      "Difficulty": "Easy"
    },
    {
      "title": "Rising Temperature",
      "description": "Given a Weather table, write a SQL query to find all dates' Ids with higher temperature compared to its previous (yesterday's) dates.\n+---------+------------+------------------+\n| Id(INT) | Date(DATE) | Temperature(INT) |\n+---------+------------+------------------+\n|       1 | 2015-01-01 |               10 |\n|       2 | 2015-01-02 |               25 |\n|       3 | 2015-01-03 |               20 |\n|       4 | 2015-01-04 |               30 |\n+---------+------------+------------------+\nFor example, return the following Ids for the above Weather table:+----+\n| Id |\n+----+\n|  2 |\n|  4 |\n+----+",
      "example": "",
      "solution": "SolutionApproach: Using JOIN and DATEDIFF() clause [Accepted]\nAlgorithm\nMySQL uses DATEDIFF to compare two date type values.\nSo, we can get the result by joining this table weather with itself and use this DATEDIFF() function.\nMySQL\nSELECT\n    weather.id AS 'Id'\nFROM\n    weather\n        JOIN\n    weather w ON DATEDIFF(weather.date, w.date) = 1\n        AND weather.Temperature > w.Temperature\n;",
      "extra": "nothing",
      "Difficulty": "Easy"
    },
    {
      "title": "Trips and Users",
      "description": "The Trips table holds all taxi trips. Each trip has a unique Id, while Client_Id and Driver_Id are both foreign keys to the Users_Id at the Users table. Status is an ENUM type of (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’).\n+----+-----------+-----------+---------+--------------------+----------+\n| Id | Client_Id | Driver_Id | City_Id |        Status      |Request_at|\n+----+-----------+-----------+---------+--------------------+----------+\n| 1  |     1     |    10     |    1    |     completed      |2013-10-01|\n| 2  |     2     |    11     |    1    | cancelled_by_driver|2013-10-01|\n| 3  |     3     |    12     |    6    |     completed      |2013-10-01|\n| 4  |     4     |    13     |    6    | cancelled_by_client|2013-10-01|\n| 5  |     1     |    10     |    1    |     completed      |2013-10-02|\n| 6  |     2     |    11     |    6    |     completed      |2013-10-02|\n| 7  |     3     |    12     |    6    |     completed      |2013-10-02|\n| 8  |     2     |    12     |    12   |     completed      |2013-10-03|\n| 9  |     3     |    10     |    12   |     completed      |2013-10-03| \n| 10 |     4     |    13     |    12   | cancelled_by_driver|2013-10-03|\n+----+-----------+-----------+---------+--------------------+----------+\n\nThe Users table holds all users. Each user has an unique Users_Id, and Role is an ENUM type of (‘client’, ‘driver’, ‘partner’).\n+----------+--------+--------+\n| Users_Id | Banned |  Role  |\n+----------+--------+--------+\n|    1     |   No   | client |\n|    2     |   Yes  | client |\n|    3     |   No   | client |\n|    4     |   No   | client |\n|    10    |   No   | driver |\n|    11    |   No   | driver |\n|    12    |   No   | driver |\n|    13    |   No   | driver |\n+----------+--------+--------+\n\nWrite a SQL query to find the cancellation rate of requests made by unbanned clients between Oct 1, 2013 and Oct 3, 2013. For the above tables, your SQL query should return the following rows with the cancellation rate being rounded to two decimal places.\n+------------+-------------------+\n|     Day    | Cancellation Rate |\n+------------+-------------------+\n| 2013-10-01 |       0.33        |\n| 2013-10-02 |       0.00        |\n| 2013-10-03 |       0.50        |\n+------------+-------------------+",
      "example": "",
      "solution": "select \nt.Request_at Day, \nround(sum(case when t.Status like 'cancelled_%' then 1 else 0 end)/count(*),2) Rate\nfrom Trips t \ninner join Users u \non t.Client_Id = u.Users_Id and u.Banned='No'\nwhere t.Request_at between '2013-10-01' and '2013-10-03'\ngroup by t.Request_at",
      "extra": "nothing",
      "Difficulty": "Hard"
    },
    {
      "title": "Big Countries",
      "description": "There is a table World\n+-----------------+------------+------------+--------------+---------------+\n| name            | continent  | area       | population   | gdp           |\n+-----------------+------------+------------+--------------+---------------+\n| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |\n| Albania         | Europe     | 28748      | 2831741      | 12960000      |\n| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |\n| Andorra         | Europe     | 468        | 78115        | 3712000       |\n| Angola          | Africa     | 1246700    | 20609294     | 100990000     |\n+-----------------+------------+------------+--------------+---------------+\n\nA country is big if it has an area of bigger than 3 million square km or a population of more than 25 million.\nWrite a SQL solution to output big countries' name, population and area.\nFor example, according to the above table, we should output:\n+--------------+-------------+--------------+\n| name         | population  | area         |\n+--------------+-------------+--------------+\n| Afghanistan  | 25500100    | 652230       |\n| Algeria      | 37100000    | 2381741      |\n+--------------+-------------+--------------+",
      "example": "",
      "solution": "SolutionApproach I: Using WHERE clause and OR [Accepted]\nIntuition\nUse WHERE clause in SQL to filter these records and get the target countries.\nAlgorithm\nAccording to the definition, a big country meets at least one of the following two conditions: 1. It has an area of bigger than 3 million square km. 2. It has a population of more than 25 million.\nSo for the first condition, we can use the following code to get the big countries of this type.\nSELECT name, population, area FROM world WHERE area > 3000000\n\nIn addition, we can use below code to get big countries of more than 25 million people.\nSELECT name, population, area FROM world WHERE population > 25000000\n\nAs most people may already come into mind, we can use OR to combine these two solutions for the two sub-problems together.\nMySQL\nSELECT\n    name, population, area\nFROM\n    world\nWHERE\n    area > 3000000 OR population > 25000000\n;\n\nApproach II: Using WHERE clause and UNION [Accepted]\nAlgorithm\nThe idea of this approach is the same as the first one. However, we use UNIONinstead of OR.\nMySQL\nSELECT\n    name, population, area\nFROM\n    world\nWHERE\n    area > 3000000\n\nUNION\n\nSELECT\n    name, population, area\nFROM\n    world\nWHERE\n    population > 25000000\n;\n\nNote: This solution runs a little bit faster than the first one. However, they do not have big difference.",
      "extra": "nothing",
      "Difficulty": "Easy"
    },
    {
      "title": "Classes More Than 5 Students",
      "description": "There is a table courses with columns: student and class\nPlease list out all classes which have more than or equal to 5 students.\nFor example, the table:\n+---------+------------+\n| student | class      |\n+---------+------------+\n| A       | Math       |\n| B       | English    |\n| C       | Math       |\n| D       | Biology    |\n| E       | Math       |\n| F       | Computer   |\n| G       | Math       |\n| H       | Math       |\n| I       | Math       |\n+---------+------------+\n\nShould output:\n+---------+\n| class   |\n+---------+\n| Math    |\n+---------+",
      "example": "",
      "solution": "SolutionApproach: Using GROUP BY clause and sub-query [Accepted]\nIntuition\nFirst, we can count the student number in each class. And then select the ones have more than 5 students.\nAlgorithm\nTo get the student number in each class. We can use GROUP BY and COUNT, which is very popular used to statistic bases on some character in a table.\nSELECT\n    class, COUNT(DISTINCT student)\nFROM\n    courses\nGROUP BY class\n;\n\nNote: We use DISTINCT here since the student name may duplicated in a class as it is mentioned int he problem description.\n| class    | COUNT(student) |\n|----------|----------------|\n| Biology  | 1              |\n| Computer | 1              |\n| English  | 1              |\n| Math     | 6              |\n\nTo continue, we can filter the classes by taking the above query as a sub-query.\nSELECT\n    class\nFROM\n    (SELECT\n        class, COUNT(DISTINCT student) AS num\n    FROM\n        courses\n    GROUP BY class) AS temp_table\nWHERE\n    num >= 5\n;\n\nNote: Make an alias of COUNT(student) ('num' in this case) so that you can use in the WHERE clause because it cannot be used directly over there.\nApproach: Using GROUP BY and HAVING condition [Accepted]\nAlgorithm\nUsing sub-query is one way to add some condition to a GROUP BY clause, however, using HAVING is another simpler and natural approach. So we can rewrite the above solution as below.\nMySQL\nSELECT\n    class\nFROM\n    courses\nGROUP BY class\nHAVING COUNT(DISTINCT student) >= 5\n;",
      "extra": "nothing",
      "Difficulty": "Hard"
    },
    {
      "title": "Human Traffic of Stadium",
      "description": "X city built a new stadium, each day many people visit it and the stats are saved as these columns: id, date, people\nPlease write a query to display the records which have 3 or more consecutive rows and the amount of people more than 100(inclusive).\nFor example, the table stadium:+------+------------+-----------+\n| id   | date       | people    |\n+------+------------+-----------+\n| 1    | 2017-01-01 | 10        |\n| 2    | 2017-01-02 | 109       |\n| 3    | 2017-01-03 | 150       |\n| 4    | 2017-01-04 | 99        |\n| 5    | 2017-01-05 | 145       |\n| 6    | 2017-01-06 | 1455      |\n| 7    | 2017-01-07 | 199       |\n| 8    | 2017-01-08 | 188       |\n+------+------------+-----------+\n\nFor the sample data above, the output is:\n+------+------------+-----------+\n| id   | date       | people    |\n+------+------------+-----------+\n| 5    | 2017-01-05 | 145       |\n| 6    | 2017-01-06 | 1455      |\n| 7    | 2017-01-07 | 199       |\n| 8    | 2017-01-08 | 188       |\n+------+------------+-----------+",
      "example": "",
      "solution": "Approach: Using JOIN and WHERE clause [Accepted]\nIntuition\nSelect the days with more than 100 people attending the stadium, and join this temp table with itself. We might get the solution after using complex conditions in a WHEREclause.\nAlgorithm\nThe first step is to get the days with 100 people and join this table with itself.\nselect distinct t1.*\nfrom stadium t1, stadium t2, stadium t3\nwhere t1.people >= 100 and t2.people >= 100 and t3.people >= 100\n;\n\niddatepeopleiddatepeopleiddatepeople22017-01-0210922017-01-0210922017-01-0210932017-01-0315022017-01-0210922017-01-0210952017-01-0514522017-01-0210922017-01-0210962017-01-06145522017-01-0210922017-01-0210972017-01-0719922017-01-0210922017-01-0210982017-01-0818822017-01-0210922017-01-0210922017-01-0210932017-01-0315022017-01-0210932017-01-0315032017-01-0315022017-01-0210952017-01-0514532017-01-0315022017-01-0210962017-01-06145532017-01-0315022017-01-0210972017-01-0719932017-01-0315022017-01-0210982017-01-0818832017-01-0315022017-01-0210922017-01-0210952017-01-0514522017-01-0210932017-01-0315052017-01-0514522017-01-0210952017-01-0514552017-01-0514522017-01-0210962017-01-06145552017-01-0514522017-01-0210972017-01-0719952017-01-0514522017-01-0210982017-01-0818852017-01-0514522017-01-0210922017-01-0210962017-01-06145522017-01-0210932017-01-0315062017-01-06145522017-01-0210952017-01-0514562017-01-06145522017-01-0210962017-01-06145562017-01-06145522017-01-0210972017-01-0719962017-01-06145522017-01-0210982017-01-0818862017-01-06145522017-01-0210922017-01-0210972017-01-0719922017-01-0210932017-01-0315072017-01-0719922017-01-0210952017-01-0514572017-01-0719922017-01-0210962017-01-06145572017-01-0719922017-01-0210972017-01-0719972017-01-0719922017-01-0210982017-01-0818872017-01-0719922017-01-0210922017-01-0210982017-01-0818822017-01-0210932017-01-0315082017-01-0818822017-01-0210952017-01-0514582017-01-0818822017-01-0210962017-01-06145582017-01-0818822017-01-0210972017-01-0719982017-01-0818822017-01-0210982017-01-0818882017-01-0818822017-01-0210922017-01-0210922017-01-0210932017-01-0315032017-01-0315022017-01-0210932017-01-0315052017-01-0514522017-01-0210932017-01-0315062017-01-06145522017-01-0210932017-01-0315072017-01-0719922017-01-0210932017-01-0315082017-01-0818822017-01-0210932017-01-0315022017-01-0210932017-01-0315032017-01-0315032017-01-0315032017-01-0315032017-01-0315052017-01-0514532017-01-0315032017-01-0315062017-01-06145532017-01-0315032017-01-0315072017-01-0719932017-01-0315032017-01-0315082017-01-0818832017-01-0315032017-01-0315022017-01-0210952017-01-0514532017-01-0315032017-01-0315052017-01-0514532017-01-0315052017-01-0514552017-01-0514532017-01-0315062017-01-06145552017-01-0514532017-01-0315072017-01-0719952017-01-0514532017-01-0315082017-01-0818852017-01-0514532017-01-0315022017-01-0210962017-01-06145532017-01-0315032017-01-0315062017-01-06145532017-01-0315052017-01-0514562017-01-06145532017-01-0315062017-01-06145562017-01-06145532017-01-0315072017-01-0719962017-01-06145532017-01-0315082017-01-0818862017-01-06145532017-01-0315022017-01-0210972017-01-0719932017-01-0315032017-01-0315072017-01-0719932017-01-0315052017-01-0514572017-01-0719932017-01-0315062017-01-06145572017-01-0719932017-01-0315072017-01-0719972017-01-0719932017-01-0315082017-01-0818872017-01-0719932017-01-0315022017-01-0210982017-01-0818832017-01-0315032017-01-0315082017-01-0818832017-01-0315052017-01-0514582017-01-0818832017-01-0315062017-01-06145582017-01-0818832017-01-0315072017-01-0719982017-01-0818832017-01-0315082017-01-0818882017-01-0818832017-01-0315022017-01-0210922017-01-0210952017-01-0514532017-01-0315022017-01-0210952017-01-0514552017-01-0514522017-01-0210952017-01-0514562017-01-06145522017-01-0210952017-01-0514572017-01-0719922017-01-0210952017-01-0514582017-01-0818822017-01-0210952017-01-0514522017-01-0210932017-01-0315052017-01-0514532017-01-0315032017-01-0315052017-01-0514552017-01-0514532017-01-0315052017-01-0514562017-01-06145532017-01-0315052017-01-0514572017-01-0719932017-01-0315052017-01-0514582017-01-0818832017-01-0315052017-01-0514522017-01-0210952017-01-0514552017-01-0514532017-01-0315052017-01-0514552017-01-0514552017-01-0514552017-01-0514552017-01-0514562017-01-06145552017-01-0514552017-01-0514572017-01-0719952017-01-0514552017-01-0514582017-01-0818852017-01-0514552017-01-0514522017-01-0210962017-01-06145552017-01-0514532017-01-0315062017-01-06145552017-01-0514552017-01-0514562017-01-06145552017-01-0514562017-01-06145562017-01-06145552017-01-0514572017-01-0719962017-01-06145552017-01-0514582017-01-0818862017-01-06145552017-01-0514522017-01-0210972017-01-0719952017-01-0514532017-01-0315072017-01-0719952017-01-0514552017-01-0514572017-01-0719952017-01-0514562017-01-06145572017-01-0719952017-01-0514572017-01-0719972017-01-0719952017-01-0514582017-01-0818872017-01-0719952017-01-0514522017-01-0210982017-01-0818852017-01-0514532017-01-0315082017-01-0818852017-01-0514552017-01-0514582017-01-0818852017-01-0514562017-01-06145582017-01-0818852017-01-0514572017-01-0719982017-01-0818852017-01-0514582017-01-0818882017-01-0818852017-01-0514522017-01-0210922017-01-0210962017-01-06145532017-01-0315022017-01-0210962017-01-06145552017-01-0514522017-01-0210962017-01-06145562017-01-06145522017-01-0210962017-01-06145572017-01-0719922017-01-0210962017-01-06145582017-01-0818822017-01-0210962017-01-06145522017-01-0210932017-01-0315062017-01-06145532017-01-0315032017-01-0315062017-01-06145552017-01-0514532017-01-0315062017-01-06145562017-01-06145532017-01-0315062017-01-06145572017-01-0719932017-01-0315062017-01-06145582017-01-0818832017-01-0315062017-01-06145522017-01-0210952017-01-0514562017-01-06145532017-01-0315052017-01-0514562017-01-06145552017-01-0514552017-01-0514562017-01-06145562017-01-06145552017-01-0514562017-01-06145572017-01-0719952017-01-0514562017-01-06145582017-01-0818852017-01-0514562017-01-06145522017-01-0210962017-01-06145562017-01-06145532017-01-0315062017-01-06145562017-01-06145552017-01-0514562017-01-06145562017-01-06145562017-01-06145562017-01-06145562017-01-06145572017-01-0719962017-01-06145562017-01-06145582017-01-0818862017-01-06145562017-01-06145522017-01-0210972017-01-0719962017-01-06145532017-01-0315072017-01-0719962017-01-06145552017-01-0514572017-01-0719962017-01-06145562017-01-06145572017-01-0719962017-01-06145572017-01-0719972017-01-0719962017-01-06145582017-01-0818872017-01-0719962017-01-06145522017-01-0210982017-01-0818862017-01-06145532017-01-0315082017-01-0818862017-01-06145552017-01-0514582017-01-0818862017-01-06145562017-01-06145582017-01-0818862017-01-06145572017-01-0719982017-01-0818862017-01-06145582017-01-0818882017-01-0818862017-01-06145522017-01-0210922017-01-0210972017-01-0719932017-01-0315022017-01-0210972017-01-0719952017-01-0514522017-01-0210972017-01-0719962017-01-06145522017-01-0210972017-01-0719972017-01-0719922017-01-0210972017-01-0719982017-01-0818822017-01-0210972017-01-0719922017-01-0210932017-01-0315072017-01-0719932017-01-0315032017-01-0315072017-01-0719952017-01-0514532017-01-0315072017-01-0719962017-01-06145532017-01-0315072017-01-0719972017-01-0719932017-01-0315072017-01-0719982017-01-0818832017-01-0315072017-01-0719922017-01-0210952017-01-0514572017-01-0719932017-01-0315052017-01-0514572017-01-0719952017-01-0514552017-01-0514572017-01-0719962017-01-06145552017-01-0514572017-01-0719972017-01-0719952017-01-0514572017-01-0719982017-01-0818852017-01-0514572017-01-0719922017-01-0210962017-01-06145572017-01-0719932017-01-0315062017-01-06145572017-01-0719952017-01-0514562017-01-06145572017-01-0719962017-01-06145562017-01-06145572017-01-0719972017-01-0719962017-01-06145572017-01-0719982017-01-0818862017-01-06145572017-01-0719922017-01-0210972017-01-0719972017-01-0719932017-01-0315072017-01-0719972017-01-0719952017-01-0514572017-01-0719972017-01-0719962017-01-06145572017-01-0719972017-01-0719972017-01-0719972017-01-0719972017-01-0719982017-01-0818872017-01-0719972017-01-0719922017-01-0210982017-01-0818872017-01-0719932017-01-0315082017-01-0818872017-01-0719952017-01-0514582017-01-0818872017-01-0719962017-01-06145582017-01-0818872017-01-0719972017-01-0719982017-01-0818872017-01-0719982017-01-0818882017-01-0818872017-01-0719922017-01-0210922017-01-0210982017-01-0818832017-01-0315022017-01-0210982017-01-0818852017-01-0514522017-01-0210982017-01-0818862017-01-06145522017-01-0210982017-01-0818872017-01-0719922017-01-0210982017-01-0818882017-01-0818822017-01-0210982017-01-0818822017-01-0210932017-01-0315082017-01-0818832017-01-0315032017-01-0315082017-01-0818852017-01-0514532017-01-0315082017-01-0818862017-01-06145532017-01-0315082017-01-0818872017-01-0719932017-01-0315082017-01-0818882017-01-0818832017-01-0315082017-01-0818822017-01-0210952017-01-0514582017-01-0818832017-01-0315052017-01-0514582017-01-0818852017-01-0514552017-01-0514582017-01-0818862017-01-06145552017-01-0514582017-01-0818872017-01-0719952017-01-0514582017-01-0818882017-01-0818852017-01-0514582017-01-0818822017-01-0210962017-01-06145582017-01-0818832017-01-0315062017-01-06145582017-01-0818852017-01-0514562017-01-06145582017-01-0818862017-01-06145562017-01-06145582017-01-0818872017-01-0719962017-01-06145582017-01-0818882017-01-0818862017-01-06145582017-01-0818822017-01-0210972017-01-0719982017-01-0818832017-01-0315072017-01-0719982017-01-0818852017-01-0514572017-01-0719982017-01-0818862017-01-06145572017-01-0719982017-01-0818872017-01-0719972017-01-0719982017-01-0818882017-01-0818872017-01-0719982017-01-0818822017-01-0210982017-01-0818882017-01-0818832017-01-0315082017-01-0818882017-01-0818852017-01-0514582017-01-0818882017-01-0818862017-01-06145582017-01-0818882017-01-0818872017-01-0719982017-01-0818882017-01-0818882017-01-0818882017-01-0818882017-01-08188Note: - There are 6 days with more than 100 people. So there are 216(666) records in total after Cartesian product. - The first 3 columns are from t1, and the next 3 ones are from t2, and the last 3 are from t3.\nConsidering t1, t2 and t3 are identical, we can take one of them to consider what conditions we should add to filter the data and get the final result. Taking t1 for example, it could exist in the beginning of the consecutive 3 days, or the middle, or the last.\nt1 in the beginning: (t1.id - t2.id = 1 and t1.id - t3.id = 2 and t2.id - t3.id =1) -- t1, t2, t3t1 in the middle: (t2.id - t1.id = 1 and t2.id - t3.id = 2 and t1.id - t3.id =1) -- t2, t1, t3t1 in the end: (t3.id - t2.id = 1 and t2.id - t1.id =1 and t3.id - t1.id = 2) -- t3, t2, t1\nSo if we add these conditions in the SQL code, we can get this.\nselect t1.*\nfrom stadium t1, stadium t2, stadium t3\nwhere t1.people >= 100 and t2.people >= 100 and t3.people >= 100\nand\n(\n      (t1.id - t2.id = 1 and t1.id - t3.id = 2 and t2.id - t3.id =1)  -- t1, t2, t3\n    or\n    (t2.id - t1.id = 1 and t2.id - t3.id = 2 and t1.id - t3.id =1) -- t2, t1, t3\n    or\n    (t3.id - t2.id = 1 and t2.id - t1.id =1 and t3.id - t1.id = 2) -- t3, t2, t1\n)\n;\n\n| id | date       | people |\n|----|------------|--------|\n| 7  | 2017-01-07 | 199    |\n| 6  | 2017-01-06 | 1455   |\n| 8  | 2017-01-08 | 188    |\n| 7  | 2017-01-07 | 199    |\n| 5  | 2017-01-05 | 145    |\n| 6  | 2017-01-06 | 1455   |\n\nYou may notice some records duplicates since they appear in different positions. So, we can use DISTINCT to deal with it.\nMySQL\nselect distinct t1.*\nfrom stadium t1, stadium t2, stadium t3\nwhere t1.people >= 100 and t2.people >= 100 and t3.people >= 100\nand\n(\n      (t1.id - t2.id = 1 and t1.id - t3.id = 2 and t2.id - t3.id =1)  -- t1, t2, t3\n    or\n    (t2.id - t1.id = 1 and t2.id - t3.id = 2 and t1.id - t3.id =1) -- t2, t1, t3\n    or\n    (t3.id - t2.id = 1 and t2.id - t1.id =1 and t3.id - t1.id = 2) -- t3, t2, t1\n)\norder by t1.id\n;",
      "extra": "nothing",
      "Difficulty": "Hard"
    }
  ]
}