{
  "Questions": [
    {
      "title": "Two Sum",
      "description": "Given an array of integers, return indices of the two numbers such that they add up to a specific target.",
      "example": "Example: \nGiven nums = [2, 7, 11, 15], target = 9, \nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].",
      "solution": "public int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[] { map.get(complement), i };\n        }\n        map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}",
      "Difficulty": "Easy",
      "extra": ""
    },
    {
      "title": "Add Two Numbers",
      "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.",
      "example": "Example: \nInput: (2 -> 4 -> 3) + (5 -> 6 -> 4)\nOutput: 7 -> 0 -> 8",
      "solution": "public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    ListNode dummyHead = new ListNode(0);\n    ListNode p = l1, q = l2, curr = dummyHead;\n    int carry = 0;\n    while (p != null || q != null) {\n        int x = (p != null) ? p.val : 0;\n        int y = (q != null) ? q.val : 0;\n        int sum = carry + x + y;\n        carry = sum / 10;\n        curr.next = new ListNode(sum % 10);\n        curr = curr.next;\n        if (p != null) p = p.next;\n        if (q != null) q = q.next;\n    }\n    if (carry > 0) {\n        curr.next = new ListNode(carry);\n    }\n    return dummyHead.next;\n}",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "Median of Two Sorted Arrays",
      "description": "There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O (log (m+n)).",
      "example": "Example 1: \nnums1 = [1, 3] \nnums2 = [2] \nThe median is 2.0 \nExample 2: \nnums1 = [1, 2] \nnums2 = [3, 4] \nThe median is (2 + 3)/2 = 2.5",
      "solution": "\ndef median(A, B):\n    m, n = len(A), len(B)\n    if m > n:\n        A, B, m, n = B, A, n, m\n    if n == 0:\n        raise ValueError\n\n    imin, imax, half_len = 0, m, (m + n + 1) / 2\n    while imin <= imax:\n        i = (imin + imax) / 2\n        j = half_len - i\n        if i < m and B[j - 1] > A[i]:\n            # i is too small, must increase it\n            imin = i + 1\n        elif i > 0 and A[i - 1] > B[j]:\n            # i is too big, must decrease it\n            imax = i - 1\n        else:\n            # i is perfect\n\n            if i == 0:\n                max_of_left = B[j - 1]\n            elif j == 0:\n                max_of_left = A[i - 1]\n            else:\n                max_of_left = max(A[i - 1], B[j - 1])\n\n            if (m + n) % 2 == 1:\n                return max_of_left\n\n            if i == m:\n                min_of_right = B[j]\n            elif j == n:\n                min_of_right = A[i]\n            else:\n                min_of_right = min(A[i], B[j])\n\n            return (max_of_left + min_of_right) / 2.0",
      "extra": "",
      "Difficulty": "Hard"
    },
    {
      "title": "Longest Substring Without Repeating Characters",
      "description": "Given a string, find the length of the longest substring without repeating characters.",
      "example": "Examples:\nGiven \"abcabcbb\", the answer is \"abc\", which the length is 3.\nGiven \"bbbbb\", the answer is \"b\", with the length of 1.\nGiven \"pwwkew\", the answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring.",
      "solution": "public class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length(), ans = 0;\n        int[] index = new int[128]; // current index of character\n        // try to extend the range [i, j]\n        for (int j = 0, i = 0; j < n; j++) {\n            i = Math.max(index[s.charAt(j)], i);\n            ans = Math.max(ans, j - i + 1);\n            index[s.charAt(j)] = j + 1;\n        }\n        return ans;\n    }\n}",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "ZigZag Conversion",
      "description": "The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) \nP   A   H   N\nA P L S I I G\nY   I   R  \nAnd then read line by line: \"PAHNAPLSIIGYIR\" \nWrite the code that will take a string and make this conversion given a number of rows:\nstring convert(string text, int nRows);\n",
      "example": "convert(\"PAYPALISHIRING\", 3) should return \"PAHNAPLSIIGYIR\".",
      "solution": "public String convert(String s, int nRows) {\n    char[] c = s.toCharArray();\n    int len = c.length;\n    StringBuffer[] sb = new StringBuffer[nRows];\n    for (int i = 0; i < sb.length; i++) sb[i] = new StringBuffer();\n    \n    int i = 0;\n    while (i < len) {\n        for (int idx = 0; idx < nRows && i < len; idx++) // vertically down\n            sb[idx].append(c[i++]);\n        for (int idx = nRows-2; idx >= 1 && i < len; idx--) // obliquely up\n            sb[idx].append(c[i++]);\n    }\n    for (int idx = 1; idx < sb.length; idx++)\n        sb[0].append(sb[idx]);\n    return sb[0].toString();\n}",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "Reverse Integer",
      "description": "Reverse digits of an integer.",
      "example": "Example1: x = 123, return 321\n\nExample2: x = -123, return -321",
      "solution": "public int reverse(int x)\n{\n    int result = 0;\n\n    while (x != 0)\n    {\n        int tail = x % 10;\n        int newResult = result * 10 + tail;\n        if ((newResult - tail) / 10 != result)\n        { return 0; }\n        result = newResult;\n        x = x / 10;\n    }\n\n    return result;\n}",
      "extra": "",
      "Difficulty": "Easy"
    },
    {
      "title": "String to Integer (atoi)",
      "description": "Implement atoi to convert a string to an integer.\nHint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.\nNotes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.\nUpdate (2015-02-10):\nThe signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button  to reset your code definition.",
      "example": "Requirements for atoi:\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.\nThe string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.\nIf the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.\nIf no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.",
      "solution": "int atoi(const char *str) {\n    int sign = 1, base = 0, i = 0;\n    while (str[i] == ' ') { i++; }\n    if (str[i] == '-' || str[i] == '+') {\n        sign = 1 - 2 * (str[i++] == '-'); \n    }\n    while (str[i] >= '0' && str[i] <= '9') {\n        if (base >  INT_MAX / 10 || (base == INT_MAX / 10 && str[i] - '0' > 7)) {\n            if (sign == 1) return INT_MAX;\n            else return INT_MIN;\n        }\n        base  = 10 * base + (str[i++] - '0');\n    }\n    return base * sign;\n}",
      "extra": "",
      "Difficulty": "Easy"
    },
    {
      "title": "Palindrome Number",
      "description": "Determine whether an integer is a palindrome. Do this without extra space.\n\n\nCould negative integers be palindromes? (ie, -1)\nIf you are thinking of converting the integer to string, note the restriction of using extra space.\nYou could also try reversing an integer. However, if you have solved the problem \"Reverse Integer\", you know that the reversed integer might overflow. How would you handle such case?\nThere is a more generic way of solving this problem.",
      "example": "",
      "solution": "public boolean isPalindrome(int x) {\n    if (x<0 || (x!=0 && x%10==0)) return false;\n    int rev = 0;\n    while (x>rev){\n  \nrev = rev*10 + x%10;  \nx = x/10;\n    }\n    return (x==rev || x==rev/10);\n}\n",
      "extra": "",
      "Difficulty": "Easy"
    },
    {
      "title": "Integer to Roman",
      "description": "Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.",
      "example": "",
      "solution": "public static String intToRoman(int num) {\n    String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\n    String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\n    String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\n    String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\n    return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];\n}",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "Longest Common Prefix",
      "description": "Write a function to find the longest common prefix string amongst an array of strings.",
      "example": "",
      "solution": "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0)\n        return \"\";\n    int minLen = Integer.MAX_VALUE;\n    for (String str : strs)\n        minLen = Math.min(minLen, str.length());\n    int low = 1;\n    int high = minLen;\n    while (low <= high) {\n        int middle = (low + high) / 2;\n        if (isCommonPrefix(strs, middle))\n            low = middle + 1;\n        else\n            high = middle - 1;\n    }\n    return strs[0].substring(0, (low + high) / 2);\n}\n\nprivate boolean isCommonPrefix(String[] strs, int len){\n    String str1 = strs[0].substring(0,len);\n    for (int i = 1; i < strs.length; i++)\n        if (!strs[i].startsWith(str1))\n            return false;\n    return true;\n}",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "3Sum",
      "description": "Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.Note: The solution set must not contain duplicate triplets.",
      "example": "For example, given array S = [-1, 0, 1, 2, -1, -4],\n\nA solution set is:\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]",
      "solution": "public List<List<Integer>> threeSum(int[] num) {\n    Arrays.sort(num);\n    List<List<Integer>> res = new LinkedList<>(); \n    for (int i = 0; i < num.length-2; i++) {\n        if (i == 0 || (i > 0 && num[i] != num[i-1])) {\n            int lo = i+1, hi = num.length-1, sum = 0 - num[i];\n            while (lo < hi) {\n                if (num[lo] + num[hi] == sum) {\n                    res.add(Arrays.asList(num[i], num[lo], num[hi]));\n                    while (lo < hi && num[lo] == num[lo+1]) lo++;\n                    while (lo < hi && num[hi] == num[hi-1]) hi--;\n                    lo++; hi--;\n                } else if (num[lo] + num[hi] < sum) lo++;\n                else hi--;\n           }\n        }\n    }\n    return res;\n}",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "Swap Nodes in Pairs",
      "description": "Given a linked list, swap every two adjacent nodes and return its head.",
      "example": "For example,\nGiven 1->2->3->4, you should return the list as 2->1->4->3.\nYour algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.\n",
      "solution": "public class Solution {\n    public ListNode swapPairs(ListNode head) {\n        if ((head == null)||(head.next == null))\n            return head;\n        ListNode n = head.next;\n        head.next = swapPairs(head.next.next);\n        n.next = head;\n        return n;\n    }\n}",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "Divide Two Integers",
      "description": "Divide two integers without using multiplication, division and mod operator.\nIf it is overflow, return MAX",
      "example": "",
      "solution": "class Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        if (!divisor || (dividend == INT_MIN && divisor == -1))\n            return INT_MAX;\n        int sign = ((dividend < 0) ^ (divisor < 0)) ? -1 : 1;\n        long long dvd = labs(dividend);\n        long long dvs = labs(divisor);\n        int res = 0;\n        while (dvd >= dvs) { \n            long long temp = dvs, multiple = 1;\n            while (dvd >= (temp << 1)) {\n                temp <<= 1;\n                multiple <<= 1;\n            }\n            dvd -= temp;\n            res += multiple;\n        }\n        return sign == 1 ? res : -res; \n    }\n};",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "3Sum Closest",
      "description": "Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.",
      "example": "    For example, given array S = {-1 2 1 -4}, and target = 1.\n    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).",
      "solution": "int threeSumClosest(vector<int> &num, int target) {        \n    vector<int> v(num.begin(), num.end()); // I didn't wanted to disturb original array.\n    int n = 0;\n    int ans = 0;\n    int sum;\n    sort(v.begin(), v.end());\n    // If less then 3 elements then return their sum\n    while (v.size() <= 3) {\n        return accumulate(v.begin(), v.end(), 0);\n    }\n    n = v.size();\n    /* v[0] v[1] v[2] ... v[i] .... v[j] ... v[k] ... v[n-2] v[n-1]\n     *                    v[i]  <=  v[j]  <= v[k] always, because we sorted our array. \n     * Now, for each number, v[i] : we look for pairs v[j] & v[k] such that \n     * absolute value of (target - (v[i] + v[j] + v[k]) is minimised.\n     * if the sum of the triplet is greater then the target it implies\n     * we need to reduce our sum, so we do K = K - 1, that is we reduce\n     * our sum by taking a smaller number.\n     * Simillarly if sum of the triplet is less then the target then we\n     * increase out sum by taking a larger number, i.e. J = J + 1.\n     */\n    ans = v[0] + v[1] + v[2];\n    for (int i = 0; i < n-2; i++) {\n        int j = i + 1;\n        int k = n - 1;\n        while (j < k) {\n            sum = v[i] + v[j] + v[k];\n            if (abs(target - ans) > abs(target - sum)) {\n                ans = sum;\n                if (ans == target) return ans;\n            }\n            (sum > target) ? k-- : j++;\n        }\n    }\n    return ans;\n}",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": " Letter Combinations of a Phone Number",
      "description": "Given a digit string, return all possible letter combinations that the number could represent.\n\nA mapping of digit to letters (just like on the telephone buttons) is given below.",
      "example": "Input:Digit string \"23\"\n\nOutput: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\nAlthough the above answer is in lexicographical order, your answer could be in any order you want.",
      "solution": "    public List<String> letterCombinations(String digits) {\n    LinkedList<String> ans = new LinkedList<String>();\n    String[] mapping = new String[] {\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    ans.add(\"\");\n    for(int i =0; i<digits.length();i++){\n        int x = Character.getNumericValue(digits.charAt(i));\n        while(ans.peek().length()==i){\n            String t = ans.remove();\n            for(char s : mapping[x].toCharArray())\n                ans.add(t+s);\n        }\n    }\n    return ans;\n}",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "4Sum",
      "description": "Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\n\nNote: The solution set must not contain duplicate quadruplets.",
      "example": "For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.\n\nA solution set is:\n[\n  [-1,  0, 0, 1],\n  [-2, -1, 1, 2],\n  [-2,  0, 0, 2]\n]",
      "solution": "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        vector<vector<int>> total;\n        int n = nums.size();\n        if(n<4)  return total;\n        sort(nums.begin(),nums.end());\n        for(int i=0;i<n-3;i++)\n        {\n            if(i>0&&nums[i]==nums[i-1]) continue;\n            if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target) break;\n            if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]<target) continue;\n            for(int j=i+1;j<n-2;j++)\n            {\n                if(j>i+1&&nums[j]==nums[j-1]) continue;\n                if(nums[i]+nums[j]+nums[j+1]+nums[j+2]>target) break;\n                if(nums[i]+nums[j]+nums[n-2]+nums[n-1]<target) continue;\n                int left=j+1,right=n-1;\n                while(left<right){\n                    int sum=nums[left]+nums[right]+nums[i]+nums[j];\n                    if(sum<target) left++;\n                    else if(sum>target) right--;\n                    else{\n                        total.push_back(vector<int>{nums[i],nums[j],nums[left],nums[right]});\n                        do{left++;}while(nums[left]==nums[left-1]&&left<right);\n                        do{right--;}while(nums[right]==nums[right+1]&&left<right);\n                    }\n                }\n            }\n        }\n        return total;\n    }\n};",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "Remove Nth Node From End of List",
      "description": "Given a linked list, remove the nth node from the end of list and return its head.",
      "example": "For example,\n\n   Given linked list: 1->2->3->4->5, and n = 2.\n\n   After removing the second node from the end, the linked list becomes 1->2->3->5.\nNote:\nGiven n will always be valid.\nTry to do this in one pass.",
      "solution": "public ListNode removeNthFromEnd(ListNode head, int n) {\n    \n\n    ListNode start = new ListNode(0);\n    ListNode slow = start, fast = start;\n    slow.next = head;\n   \n\n    //Move fast in front so that the gap between slow and fast becomes n\n    for(int i=1; i<=n+1; i++)   {\n        fast = fast.next;\n    }\n    //Move fast to the end, maintaining the gap\n    while(fast != null) {\n        slow = slow.next;\n        fast = fast.next;\n    }\n    //Skip the desired node\n    slow.next = slow.next.next;\n    return start.next;\n}",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "Merge Two Sorted Lists",
      "description": "Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.",
      "example": "",
      "solution": "class Solution {\npublic:\n    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {\n        if(l1 == NULL) return l2;\n        if(l2 == NULL) return l1;\n        \n        if(l1->val < l2->val) {\n            l1->next = mergeTwoLists(l1->next, l2);\n            return l1;\n        } else {\n            l2->next = mergeTwoLists(l2->next, l1);\n            return l2;\n        }\n    }\n};",
      "extra": "",
      "Difficulty": "Easy"
    },
    {
      "title": "Generate Parentheses",
      "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
      "example": "For example, given n = 3, a solution set is: \n[\n  \"((()))\",\n  \"(()())\",\n  \"(())()\",\n  \"()(())\",\n  \"()()()\"\n]",
      "solution": " public List<String> generateParenthesis(int n) {\n        List<String> list = new ArrayList<String>();\n        backtrack(list, \"\", 0, 0, n);\n        return list;\n    }\n    \n\n    public void backtrack(List<String> list, String str, int open, int close, int max){\n       \n \n        if(str.length() == max*2){\n            list.add(str);\n            return;\n        }\n       \n\n        if(open < max)\n            backtrack(list, str+\"(\", open+1, close, max);\n        if(close < open)\n            backtrack(list, str+\")\", open, close+1, max);\n    }",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "Merge k Sorted Lists",
      "description": "Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.",
      "example": "",
      "solution": "public class Solution {\n    public ListNode mergeKLists(List<ListNode> lists) {\n        if (lists==null||lists.size()==0) return null;\n        \n\n        PriorityQueue<ListNode> queue= new PriorityQueue<ListNode>(lists.size(),new Comparator<ListNode>(){\n            @Override\n            public int compare(ListNode o1,ListNode o2){\n                if (o1.val<o2.val)\n                    return -1;\n                else if (o1.val==o2.val)\n                    return 0;\n                else \n                    return 1;\n            }\n        });\n        \n\n        ListNode dummy = new ListNode(0);\n        ListNode tail=dummy;\n        \n\n        for (ListNode node:lists)\n            if (node!=null)\n                queue.add(node);\n            \n\n        while (!queue.isEmpty()){\n            tail.next=queue.poll();\n            tail=tail.next;\n            \n\n            if (tail.next!=null)\n                queue.add(tail.next);\n        }\n        return dummy.next;\n   }\n}",
      "extra": "",
      "Difficulty": "Hard"
    },
    {
      "title": "Remove Duplicates from Sorted Array   ",
      "description": "Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.\nDo not allocate extra space for another array, you must do this in place with constant memory.\nFor example,\nGiven input array nums = [1,1,2],\nYour function should return length = 2, with the first two elements of nums being 1 and 2respectively. It doesn't matter what you leave beyond the new length.",
      "example": "",
      "solution": "Algorithm\nSince the array is already sorted, we can keep two pointers ii and jj, where ii is the slow-runner while jj is the fast-runner. As long as nums[i] = nums[j]nums[i]=nums[j], we increment jj to skip the duplicate.\nWhen we encounter nums[j] \neq nums[i]nums[j]â‰ nums[i], the duplicate run has ended so we must copy its value to nums[i + 1]nums[i+1]. ii is then incremented and we repeat the same process again until jj reaches the end of array.\npublic int removeDuplicates(int[] nums) {\n    if (nums.length == 0) return 0;\n    int i = 0;\n    for (int j = 1; j < nums.length; j++) {\n        if (nums[j] != nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n}\n\nComplexity analysis\nTime complextiy : O(n)O(n). Assume that nn is the length of array. Each of ii and jjtraverses at most nn steps.\nSpace complexity : O(1)O(1).",
      "extra": "",
      "Difficulty": "Easy"
    },
    {
      "title": "Remove Element",
      "description": "Given an array and a value, remove all instances of that value in place and return the new length.\nDo not allocate extra space for another array, you must do this in place with constant memory.\nThe order of elements can be changed. It doesn't matter what you leave beyond the new length.\nExample:\nGiven input array nums = [3,2,2,3], val = 3\nYour function should return length = 2, with the first two elements of nums being 2.",
      "example": "",
      "solution": "\nApproach #1 (Two Pointers) [Accepted]\nIntuition\nSince question asked us to remove all elements of the given value in-place, we have to handle it with O(1)O(1) extra space. How to solve it? We can keep two pointers ii and jj, where ii is the slow-runner while jj is the fast-runner.\nAlgorithm\nWhen nums[j]nums[j] equals to the given value, skip this element by incrementing jj. As long as nums[j] \neq valnums[j]â‰ val, we copy nums[j]nums[j] to nums[i]nums[i] and increment both indexes at the same time. Repeat the process until jj reaches the end of the array and the new length is ii.\nThis solution is very similar to the solution to Remove Duplicates from Sorted Array.\npublic int removeElement(int[] nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.length; j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n\nComplexity analysis\nTime complexity : O(n)O(n). Assume the array has a total of nn elements, both ii and jjtraverse at most 2n2n steps.\nSpace complexity : O(1)O(1).\nApproach #2 (Two Pointers - when elements to remove are rare) [Accepted]\nIntuition\nNow consider cases where the array contains few elements to remove. For example, nums = [1,2,3,5,4], val = 4nums=[1,2,3,5,4],val=4. The previous algorithm will do unnecessary copy operation of the first four elements. Another example is nums = [4,1,2,3,5], val = 4nums=[4,1,2,3,5],val=4. It seems unnecessary to move elements [1,2,3,5][1,2,3,5] one step left as the problem description mentions that the order of elements could be changed.\nAlgorithm\nWhen we encounter nums[i] = valnums[i]=val, we can swap the current element out with the last element and dispose the last one. This essentially reduces the array's size by 1.\nNote that the last element that was swapped in could be the value you want to remove itself. But don't worry, in the next iteration we will still check this element.\npublic int removeElement(int[] nums, int val) {\n    int i = 0;\n    int n = nums.length;\n    while (i < n) {\n        if (nums[i] == val) {\n            nums[i] = nums[n - 1];\n            // reduce array size by one\n            n--;\n        } else {\n            i++;\n        }\n    }\n    return n;\n}\n\nComplexity analysis\nTime complexity : O(n)O(n). Both ii and nn traverse at most nn steps. In this approach, the number of assignment operation is equal to the number of elements to remove. So it is more efficient if elements to remove are rare.\nSpace complexity : O(1)O(1).\nAnalysis written by @feelxia, revised by @1337c0d3r.\n",
      "extra": "",
      "Difficulty": "Easy"
    },
    {
      "title": "Implement strStr()",
      "description": "Implement strStr().\nReturns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.",
      "example": "",
      "solution": "public int strStr(String haystack, String needle) {\n  for (int i = 0; ; i++) {\n    for (int j = 0; ; j++) {\n      if (j == needle.length()) return i;\n      if (i + j == haystack.length()) return -1;\n      if (needle.charAt(j) != haystack.charAt(i + j)) break;\n    }\n  }\n}",
      "extra": "",
      "Difficulty": "Easy"
    },
    {
      "title": "Substring with Concatenation of All Words",
      "description": "You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.\nFor example, given:\ns: \"barfoothefoobarman\"\nwords: [\"foo\", \"bar\"]\nYou should return the indices: [0,9].\n(order does not matter).",
      "example": "",
      "solution": "An O(N) solution with detailed explanation\n    // travel all the words combinations to maintain a window\n    // there are wl(word len) times travel\n    // each time, n/wl words, mostly 2 times travel for each word\n    // one left side of the window, the other right side of the window\n    // so, time complexity O(wl * 2 * N/wl) = O(2N)\n    vector<int> findSubstring(string S, vector<string> &L) {\n        vector<int> ans;\n        int n = S.size(), cnt = L.size();\n        if (n <= 0 || cnt <= 0) return ans;\n        \n        // init word occurence\n        unordered_map<string, int> dict;\n        for (int i = 0; i < cnt; ++i) dict[L[i]]++;\n        \n        // travel all sub string combinations\n        int wl = L[0].size();\n        for (int i = 0; i < wl; ++i) {\n            int left = i, count = 0;\n            unordered_map<string, int> tdict;\n            for (int j = i; j <= n - wl; j += wl) {\n                string str = S.substr(j, wl);\n                // a valid word, accumulate results\n                if (dict.count(str)) {\n                    tdict[str]++;\n                    if (tdict[str] <= dict[str]) \n                        count++;\n                    else {\n                        // a more word, advance the window left side possiablly\n                        while (tdict[str] > dict[str]) {\n                            string str1 = S.substr(left, wl);\n                            tdict[str1]--;\n                            if (tdict[str1] < dict[str1]) count--;\n                            left += wl;\n                        }\n                    }\n                    // come to a result\n                    if (count == cnt) {\n                        ans.push_back(left);\n                        // advance one word\n                        tdict[S.substr(left, wl)]--;\n                        count--;\n                        left += wl;\n                    }\n                }\n                // not a valid word, reset all vars\n                else {\n                    tdict.clear();\n                    count = 0;\n                    left = j + wl;\n                }\n            }\n        }\n        \n        return ans;\n    }",
      "extra": "",
      "Difficulty": "Hard"
    },
    {
      "title": "Next Permutation",
      "description": "Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\nThe replacement must be in-place, do not allocate extra memory.\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\n1,2,3 â†’ 1,3,2\n3,2,1 â†’ 1,2,3\n1,1,5 â†’ 1,5,1",
      "example": "",
      "solution": "Java\npublic class Solution {\n    public void nextPermutation(int[] nums) {\n        int i = nums.length - 2;\n        while (i >= 0 && nums[i + 1] <= nums[i]) {\n            i--;\n        }\n        if (i >= 0) {\n            int j = nums.length - 1;\n            while (j >= 0 && nums[j] <= nums[i]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        reverse(nums, i + 1);\n    }\n\n    private void reverse(int[] nums, int start) {\n        int i = start, j = nums.length - 1;\n        while (i < j) {\n            swap(nums, i, j);\n            i++;\n            j--;\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}",
      "extra": "",
      "Difficulty": "Hard"
    },
    {
      "title": "Longest Valid Parentheses",
      "description": "Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.\nFor \"(()\", the longest valid parentheses substring is \"()\", which has length = 2.\nAnother example is \")()())\", where the longest valid parentheses substring is \"()()\", which has length = 4.\n",
      "example": "",
      "solution": "My O(n) solution using a stack\nclass Solution {\npublic:\n    int longestValidParentheses(string s) {\n        int n = s.length(), longest = 0;\n        stack<int> st;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '(') st.push(i);\n            else {\n                if (!st.empty()) {\n                    if (s[st.top()] == '(') st.pop();\n                    else st.push(i);\n                }\n                else st.push(i);\n            }\n        }\n        if (st.empty()) longest = n;\n        else {\n            int a = n, b = 0;\n            while (!st.empty()) {\n                b = st.top(); st.pop();\n                longest = max(longest, a-b-1);\n                a = b;\n            }\n            longest = max(longest, a);\n        }\n        return longest;\n    }\n};\n\nThe workflow of the solution is as below.\nScan the string from beginning to end.If current character is '(',\npush its index to the stack. If current character is ')' and the\ncharacter at the index of the top of stack is '(', we just find a\nmatching pair so pop from the stack. Otherwise, we push the index of\n')' to the stack.After the scan is done, the stack will only\ncontain the indices of characters which cannot be matched. Then\nlet's use the opposite side - substring between adjacent indices\nshould be valid parentheses.If the stack is empty, the whole input\nstring is valid. Otherwise, we can scan the stack to get longest\nvalid substring as described in step 3.",
      "extra": "",
      "Difficulty": "Hard"
    },
    {
      "title": "Search in Rotated Sorted Array",
      "description": "Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\nYou are given a target value to search. If found in the array return its index, otherwise return -1.\nYou may assume no duplicate exists in the array.\n",
      "example": "",
      "solution": "Concise O(log N) Binary search solution\nclass Solution {\npublic:\n    int search(int A[], int n, int target) {\n        int lo=0,hi=n-1;\n        // find the index of the smallest value using binary search.\n        // Loop will terminate since mid < hi, and lo or hi will shrink by at least 1.\n        // Proof by contradiction that mid < hi: if mid==hi, then lo==hi and loop would have been terminated.\n        while(lo<hi){\n            int mid=(lo+hi)/2;\n            if(A[mid]>A[hi]) lo=mid+1;\n            else hi=mid;\n        }\n        // lo==hi is the index of the smallest value and also the number of places rotated.\n        int rot=lo;\n        lo=0;hi=n-1;\n        // The usual binary search and accounting for rotation.\n        while(lo<=hi){\n            int mid=(lo+hi)/2;\n            int realmid=(mid+rot)%n;\n            if(A[realmid]==target)return realmid;\n            if(A[realmid]<target)lo=mid+1;\n            else hi=mid-1;\n        }\n        return -1;\n    }\n};",
      "extra": "",
      "Difficulty": "Hard"
    },
    {
      "title": "Search for a Range",
      "solution": "vector <int> searchRange(int A[], int n, int target) {\n    int i = 0, j = n - 1;\n    vector<int> ret(2, -1);\n    // Search for the left one\n    while (i < j)\n    {\n        int mid = (i + j) /2;\n        if (A[mid] < target) i = mid + 1;\n        else j = mid;\n    }\n    if (A[i]!=target) return ret;\n    else ret[0] = i;\n    \n    // Search for the right one\n    j = n-1;  // We don't have to set i to 0 the second time.\n    while (i < j)\n    {\n        int mid = (i + j) /2 + 1;\n\n else j = mid;\n }\n    if (A[i]!=target) return ret;\n    else ret[0] = i;\n\n   j = n-1; \n  while (i < j)\n    {\n   int mid = (i + j) /2 + 1;\n\n if (A[mid] > target) j = mid - 1;\n\n else i = mid;\n    }\n    ret[1] = j;\n    return ret; \n}\n\n\n// Make mid biased to the right\n// So that this won't make the search range stuck.",
      "description": "Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.\nYour algorithm's runtime complexity must be in the order of O(log n).\nIf the target is not found in the array, return [-1, -1].\nFor example,\nGiven [5, 7, 7, 8, 8, 10] and target value 8,\nreturn [3, 4].",
      "example": "",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "Search Insert Position",
      "description": "Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou may assume no duplicates in the array.\nHere are few examples.\n[1,3,5,6], 5 â†’ 2\n[1,3,5,6], 2 â†’ 1\n[1,3,5,6], 7 â†’ 4\n[1,3,5,6], 0 â†’ 0\n",
      "example": "",
      "solution": "   public int searchInsert(int[] A, int target) {\n        int low = 0, high = A.length-1;\n        while(low<=high){\n            int mid = (low+high)/2;\n            if(A[mid] == target) return mid;\n            else if(A[mid] > target) high = mid-1;\n            else low = mid+1;\n        }\n        return low;\n    }",
      "extra": "",
      "Difficulty": "Easy"
    },
    {
      "title": "Valid Sudoku",
      "description": "Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.\nThe Sudoku board could be partially filled, where empty cells are filled with the character '.'.\n\n\nA valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\n\n",
      "example": "\nexample jpg below \n",
      "solution": "Three flags are used to check whether a number appear.\nused1: check each row\nused2: check each column\nused3: check each sub-boxes\nclass Solution\n{\npublic:\n    bool isValidSudoku(vector<vector<char> > &board)\n    {\n        int used1[9][9] = {0}, used2[9][9] = {0}, used3[9][9] = {0};\n        \n        for(int i = 0; i < board.size(); ++ i)\n            for(int j = 0; j < board[i].size(); ++ j)\n                if(board[i][j] != '.')\n                {\n                    int num = board[i][j] - '0' - 1, k = i / 3 * 3 + j / 3;\n                    if(used1[i][num] || used2[j][num] || used3[k][num])\n                        return false;\n                    used1[i][num] = used2[j][num] = used3[k][num] = 1;\n                }\n        \n        return true;\n    }\n};",
      "extra": "http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png",
      "Difficulty": "Medium"
    },
    {
      "title": "Sudoku Solver",
      "description": "Write a program to solve a Sudoku puzzle by filling the empty cells.\nEmpty cells are indicated by the character '.'.\nYou may assume that there will be only one unique solution.",
      "example": "Example jpg Below\n\n\n\nA sudoku puzzle...\n\n\nhttp://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png\n\n...and its solution numbers marked in red.\n",
      "solution": "public class Solution {\n    public void solveSudoku(char[][] board) {\n        if(board == null || board.length == 0)\n            return;\n        solve(board);\n    }\n    \n    public boolean solve(char[][] board){\n        for(int i = 0; i < board.length; i++){\n            for(int j = 0; j < board[0].length; j++){\n                if(board[i][j] == '.'){\n                    for(char c = '1'; c <= '9'; c++){//trial. Try 1 through 9\n                        if(isValid(board, i, j, c)){\n                            board[i][j] = c; //Put c for this cell\n                            \n                            if(solve(board))\n                                return true; //If it's the solution return true\n                            else\n                                board[i][j] = '.'; //Otherwise go back\n                        }\n                    }\n                    \n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    private boolean isValid(char[][] board, int row, int col, char c){\n        for(int i = 0; i < 9; i++) {\n            if(board[i][col] != '.' && board[i][col] == c) return false; //check row\n            if(board[row][i] != '.' && board[row][i] == c) return false; //check column\n            if(board[3 * (row / 3) + i / 3][ 3 * (col / 3) + i % 3] != '.' && \nboard[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false; //check 3*3 block\n        }\n        return true;\n    }\n}",
      "extra": "https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png",
      "Difficulty": "Hard"
    },
    {
      "title": "Combination Sum",
      "description": "Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\nThe same repeated number may be chosen from C unlimited number of times.\nNote:\nAll numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.\n\nFor example, given candidate set [2, 3, 6, 7] and target 7, \nA solution set is: \n[\n  [7],\n  [2, 2, 3]\n]",
      "example": "",
      "solution": "This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum.\nSubsets : https://leetcode.com/problems/subsets/\npublic List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\n    list.add(new ArrayList<>(tempList));\n    for(int i = start; i < nums.length; i++){\n        tempList.add(nums[i]);\n        backtrack(list, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n}\n\nSubsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\n    list.add(new ArrayList<>(tempList));\n    for(int i = start; i < nums.length; i++){\n        if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\n        tempList.add(nums[i]);\n        backtrack(list, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n} \n\nPermutations : https://leetcode.com/problems/permutations/\npublic List<List<Integer>> permute(int[] nums) {\n   List<List<Integer>> list = new ArrayList<>();\n   // Arrays.sort(nums); // not necessary\n   backtrack(list, new ArrayList<>(), nums);\n   return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n   if(tempList.size() == nums.length){\n      list.add(new ArrayList<>(tempList));\n   } else{\n      for(int i = 0; i < nums.length; i++){ \n         if(tempList.contains(nums[i])) continue; // element already exists, skip\n         tempList.add(nums[i]);\n         backtrack(list, tempList, nums);\n         tempList.remove(tempList.size() - 1);\n      }\n   }\n} \n\nPermutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/\npublic List<List<Integer>> permuteUnique(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\n    if(tempList.size() == nums.length){\n        list.add(new ArrayList<>(tempList));\n    } else{\n        for(int i = 0; i < nums.length; i++){\n            if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\n            used[i] = true; \n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, used);\n            used[i] = false; \n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\n\nCombination Sum : https://leetcode.com/problems/combination-sum/\npublic List<List<Integer>> combinationSum(int[] nums, int target) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, target, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\n    if(remain < 0) return;\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\n    else{ \n        for(int i = start; i < nums.length; i++){\n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\n\nCombination Sum II (can't reuse same element) : https://leetcode.com/problems/combination-sum-ii/\npublic List<List<Integer>> combinationSum2(int[] nums, int target) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, target, 0);\n    return list;\n    \n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\n    if(remain < 0) return;\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\n    else{\n        for(int i = start; i < nums.length; i++){\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, remain - nums[i], i + 1);\n            tempList.remove(tempList.size() - 1); \n        }\n    }\n} \n\nPalindrome Partitioning : https://leetcode.com/problems/palindrome-partitioning/\npublic List<List<String>> partition(String s) {\n   List<List<String>> list = new ArrayList<>();\n   backtrack(list, new ArrayList<>(), s, 0);\n   return list;\n}\n\npublic void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\n   if(start == s.length())\n      list.add(new ArrayList<>(tempList));\n   else{\n      for(int i = start; i < s.length(); i++){\n         if(isPalindrome(s, start, i)){\n            tempList.add(s.substring(start, i + 1));\n            backtrack(list, tempList, s, i + 1);\n            tempList.remove(tempList.size() - 1);\n         }\n      }\n   }\n}\n\npublic boolean isPalindrome(String s, int low, int high){\n   while(low < high)\n      if(s.charAt(low++) != s.charAt(high--)) return false;\n   return true;\n} ",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "Combination Sum II",
      "description": "Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\nEach number in C may only be used once in the combination.\nNote:\nAll numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.\n\nFor example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, \nA solution set is: \n[\n  [1, 7],\n  [1, 2, 5],\n  [2, 6],\n  [1, 1, 6]\n]",
      "example": "",
      "solution": "Java solution using dfs, easy understand\n public List<List<Integer>> combinationSum2(int[] cand, int target) {\n    Arrays.sort(cand);\n    List<List<Integer>> res = new ArrayList<List<Integer>>();\n    List<Integer> path = new ArrayList<Integer>();\n    dfs_com(cand, 0, target, path, res);\n    return res;\n}\nvoid dfs_com(int[] cand, int cur, int target, List<Integer> path, List<List<Integer>> res) {\n    if (target == 0) {\n        res.add(new ArrayList(path));\n        return ;\n    }\n    if (target < 0) return;\n    for (int i = cur; i < cand.length; i++){\n        if (i > cur && cand[i] == cand[i-1]) continue;\n        path.add(path.size(), cand[i]);\n        dfs_com(cand, i+1, target - cand[i], path, res);\n        path.remove(path.size()-1);\n    }\n}",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "First Missing Positive",
      "description": "Given an unsorted integer array, find the first missing positive integer.\nFor example,\nGiven [1,2,0] return 3,\nand [3,4,-1,1] return 2.\nYour algorithm should run in O(n) time and uses constant space.",
      "example": "",
      "solution": "Put each number in its right place.\nFor example:\nWhen we find 5, then swap it with A[4].\nAt last, the first place where its number is not right, return the place + 1.\nclass Solution\n{\npublic:\n    int firstMissingPositive(int A[], int n)\n    {\n        for(int i = 0; i < n; ++ i)\n            while(A[i] > 0 && A[i] <= n && A[A[i] - 1] != A[i])\n                swap(A[i], A[A[i] - 1]);\n        \n        for(int i = 0; i < n; ++ i)\n            if(A[i] != i + 1)\n                return i + 1;\n        \n        return n + 1;\n    }\n};",
      "extra": "",
      "Difficulty": "Hard"
    },
    {
      "title": "Jump Game II",
      "description": "Nothing Yet",
      "example": "",
      "solution": "public int jump(int[] A) {\n    int sc = 0;\n    int e = 0;\n    int max = 0;\n    for(int i=0; i<A.length-1; i++) {\n        max = Math.max(max, i+A[i]);\n        if( i == e ) {\n            sc++;\n            e = max;\n        } \n    }\n    return sc;\n}",
      "extra": "",
      "Difficulty": "Hard"
    },
    {
      "title": "Pow(x, n)",
      "description": "Implement pow(x, n).\n",
      "example": "",
      "solution": "public class Solution {\n    public double pow(double x, int n) {\n        if(n == 0)\n            return 1;\n        if(n<0){\n            n = -n;\n            x = 1/x;\n        }\n        return (n%2 == 0) ? pow(x*x, n/2) : x*pow(x*x, n/2);\n    }\n}",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "N-Queens",
      "description": "The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.\nGiven an integer n, return all distinct solutions to the n-queens puzzle.\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.\nFor example,\nThere exist two distinct solutions to the 4-queens puzzle:",
      "example": "",
      "solution": "class Solution {\npublic:\n    std::vector<std::vector<std::string> > solveNQueens(int n) {\n        std::vector<std::vector<std::string> > res;\n        std::vector<std::string> nQueens(n, std::string(n, '.'));\n        solveNQueens(res, nQueens, 0, n);\n        return res;\n    }\nprivate:\n    void solveNQueens(std::vector<std::vector<std::string> > &res, std::vector<std::string> &nQueens, int row, int &n) {\n        if (row == n) {\n            res.push_back(nQueens);\n            return;\n        }\n        for (int col = 0; col != n; ++col)\n            if (isValid(nQueens, row, col, n)) {\n                nQueens[row][col] = 'Q';\n                solveNQueens(res, nQueens, row + 1, n);\n                nQueens[row][col] = '.';\n            }\n    }\n    bool isValid(std::vector<std::string> &nQueens, int row, int col, int &n) {\n        //check if the column had a queen before.\n        for (int i = 0; i != row; ++i)\n            if (nQueens[i][col] == 'Q')\n                return false;\n        //check if the 45Â° diagonal had a queen before.\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j)\n            if (nQueens[i][j] == 'Q')\n                return false;\n        //check if the 135Â° diagonal had a queen before.\n        for (int i = row - 1, j = col + 1; i >= 0 && j < n; --i, ++j)\n            if (nQueens[i][j] == 'Q')\n                return false;\n        return true;\n    }\n};\n\n\n\n\n\n\nclass Solution {\npublic:\n    std::vector<std::vector<std::string> > solveNQueens(int n) {\n        std::vector<std::vector<std::string> > res;\n        std::vector<std::string> nQueens(n, std::string(n, '.'));\n        /*\n        flag[0] to flag[n - 1] to indicate if the column had a queen before.\n        flag[n] to flag[3 * n - 2] to indicate if the 45Â° diagonal had a queen before.\n        flag[3 * n - 1] to flag[5 * n - 3] to indicate if the 135Â° diagonal had a queen before.\n        */\n        std::vector<int> flag(5 * n - 2, 1);\n        solveNQueens(res, nQueens, flag, 0, n);\n        return res;\n    }\nprivate:\n    void solveNQueens(std::vector<std::vector<std::string> > &res, std::vector<std::string> &nQueens, std::vector<int> &flag, int row, int &n) {\n        if (row == n) {\n            res.push_back(nQueens);\n            return;\n        }\n        for (int col = 0; col != n; ++col)\n            if (flag[col] && flag[n + row + col] && flag[4 * n - 2 + col - row]) {\n                flag[col] = flag[n + row + col] = flag[4 * n - 2 + col - row] = 0;\n                nQueens[row][col] = 'Q';\n                solveNQueens(res, nQueens, flag, row + 1, n);\n                nQueens[row][col] = '.';\n                flag[col] = flag[n + row + col] = flag[4 * n - 2 + col - row] = 1;\n            }\n    }\n};",
      "extra": "https://leetcode.com/static/images/problemset/8-queens.png",
      "Difficulty": "Hard"
    },
    {
      "title": "N-Queens II",
      "description": "Follow up for N-Queens problem.\nNow, instead outputting board configurations, return the total number of distinct solutions.",
      "example": "",
      "solution": "/**\n * don't need to actually place the queen,\n * instead, for each row, try to place without violation on\n * col/ diagonal1/ diagnol2.\n * trick: to detect whether 2 positions sit on the same diagnol:\n * if delta(col, row) equals, same diagnol1;\n * if sum(col, row) equals, same diagnal2.\n */\nprivate final Set<Integer> occupiedCols = new HashSet<Integer>();\nprivate final Set<Integer> occupiedDiag1s = new HashSet<Integer>();\nprivate final Set<Integer> occupiedDiag2s = new HashSet<Integer>();\npublic int totalNQueens(int n) {\n    return totalNQueensHelper(0, 0, n);\n}\n\nprivate int totalNQueensHelper(int row, int count, int n) {\n    for (int col = 0; col < n; col++) {\n        if (occupiedCols.contains(col))\n            continue;\n        int diag1 = row - col;\n        if (occupiedDiag1s.contains(diag1))\n            continue;\n        int diag2 = row + col;\n        if (occupiedDiag2s.contains(diag2))\n            continue;\n        // we can now place a queen here\n        if (row == n-1)\n            count++;\n        else {\n            occupiedCols.add(col);\n            occupiedDiag1s.add(diag1);\n            occupiedDiag2s.add(diag2);\n            count = totalNQueensHelper(row+1, count, n);\n            // recover\n            occupiedCols.remove(col);\n            occupiedDiag1s.remove(diag1);\n            occupiedDiag2s.remove(diag2);\n        }\n    }\n    \n    return count;\n}",
      "extra": "https://leetcode.com/static/images/problemset/8-queens.png",
      "Difficulty": "Hard"
    },
    {
      "title": "Maximum Subarray",
      "description": "Find the contiguous subarray within an array (containing at least one number) which has the largest sum.\nFor example, given the array [-2,1,-3,4,-1,2,1,-5,4],\nthe contiguous subarray [4,-1,2,1] has the largest sum = 6.\nclick to show more practice.\nMore practice:\nIf you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.",
      "example": "",
      "solution": "DP solution & some thoughts\nAnalysis of this problem:\nApparently, this is a optimization problem, which can be usually solved by DP. So when it comes to DP, the first thing for us to figure out is the format of the sub problem(or the state of each sub problem). The format of the sub problem can be helpful when we are trying to come up with the recursive relation.\nAt first, I think the sub problem should look like: maxSubArray(int A[], int i, int j), which means the maxSubArray for A[i: j]. In this way, our goal is to figure out what maxSubArray(A, 0, A.length - 1) is. However, if we define the format of the sub problem in this way, it's hard to find the connection from the sub problem to the original problem(at least for me). In other words, I can't find a way to divided the original problem into the sub problems and use the solutions of the sub problems to somehow create the solution of the original one.\nSo I change the format of the sub problem into something like: maxSubArray(int A[], int i), which means the maxSubArray for A[0:i ] which must has A[i] as the end element. Note that now the sub problem's format is less flexible and less powerful than the previous one because there's a limitation that A[i] should be contained in that sequence and we have to keep track of each solution of the sub problem to update the global optimal value. However, now the connect between the sub problem & the original one becomes clearer:\nmaxSubArray(A, i) = maxSubArray(A, i - 1) > 0 ? maxSubArray(A, i - 1) : 0 + A[i]; \n\nAnd here's the code\npublic int maxSubArray(int[] A) {\n        int n = A.length;\n        int[] dp = new int[n];//dp[i] means the maximum subarray ending with A[i];\n        dp[0] = A[0];\n        int max = dp[0];\n        \n        for(int i = 1; i < n; i++){\n            dp[i] = A[i] + (dp[i - 1] > 0 ? dp[i - 1] : 0);\n            max = Math.max(max, dp[i]);\n        }\n        \n        return max;\n}",
      "extra": "",
      "Difficulty": "Easy"
    },
    {
      "title": "Spiral Matrix",
      "description": "Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\nFor example,\nGiven the following matrix:\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n\nYou should return [1,2,3,6,9,8,7,4,5].",
      "example": "",
      "solution": "public class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        \n        List<Integer> res = new ArrayList<Integer>();\n        \n        if (matrix.length == 0) {\n            return res;\n        }\n        \n        int rowBegin = 0;\n        int rowEnd = matrix.length-1;\n        int colBegin = 0;\n        int colEnd = matrix[0].length - 1;\n        \n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\n            // Traverse Right\n            for (int j = colBegin; j <= colEnd; j ++) {\n                res.add(matrix[rowBegin][j]);\n            }\n            rowBegin++;\n            \n            // Traverse Down\n            for (int j = rowBegin; j <= rowEnd; j ++) {\n                res.add(matrix[j][colEnd]);\n            }\n            colEnd--;\n            \n            if (rowBegin <= rowEnd) {\n                // Traverse Left\n                for (int j = colEnd; j >= colBegin; j --) {\n                    res.add(matrix[rowEnd][j]);\n                }\n            }\n            rowEnd--;\n            \n            if (colBegin <= colEnd) {\n                // Traver Up\n                for (int j = rowEnd; j >= rowBegin; j --) {\n                    res.add(matrix[j][colBegin]);\n                }\n            }\n            colBegin ++;\n        }\n        \n        return res;\n    }\n}",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "Jump Game",
      "description": "Given an array of non-negative integers, you are initially positioned at the first index of the array.\nEach element in the array represents your maximum jump length at that position.\nDetermine if you are able to reach the last index.\nFor example:\nA = [2,3,1,1,4], return true.\nA = [3,2,1,0,4], return false.",
      "example": "",
      "solution": "public class Solution {\n    public boolean canJump(int[] nums) {\n        int lastPos = nums.length - 1;\n        for (int i = nums.length - 1; i >= 0; i--) {\n            if (i + nums[i] >= lastPos) {\n                lastPos = i;\n            }\n        }\n        return lastPos == 0;\n    }\n}",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "Merge Intervals",
      "description": "Given a collection of intervals, merge all overlapping intervals.\nFor example,\nGiven [1,3],[2,6],[8,10],[15,18],\nreturn [1,6],[8,10],[15,18].",
      "example": "",
      "solution": "A simple Java solution\nThe idea is to sort the intervals by their starting points. Then, we take the first interval and compare its end with the next intervals starts. As long as they overlap, we update the end to be the max end of the overlapping intervals. Once we find a non overlapping interval, we can add the previous \"extended\" interval and start over.\nSorting takes O(n log(n)) and merging the intervals takes O(n). So, the resulting algorithm takes O(n log(n)).\nI used an a lambda comparator (Java 8) and a for-each loop to try to keep the code clean and simple.\npublic List<Interval> merge(List<Interval> intervals) {\n    if (intervals.size() <= 1)\n        return intervals;\n    \n    // Sort by ascending starting point using an anonymous Comparator\n    intervals.sort((i1, i2) -> Integer.compare(i1.start, i2.start));\n    \n    List<Interval> result = new LinkedList<Interval>();\n    int start = intervals.get(0).start;\n    int end = intervals.get(0).end;\n    \n    for (Interval interval : intervals) {\n        if (interval.start <= end) // Overlapping intervals, move the end if needed\n            end = Math.max(end, interval.end);\n        else {                     // Disjoint intervals, add the previous one and reset bounds\n            result.add(new Interval(start, end));\n            start = interval.start;\n            end = interval.end;\n        }\n    }\n    \n    // Add the last interval\n    result.add(new Interval(start, end));\n    return result;\n}",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "Insert Interval",
      "description": "Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).\nYou may assume that the intervals were initially sorted according to their start times.\nExample 1:\nGiven intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].\nExample 2:\nGiven [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].\nThis is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].",
      "example": "",
      "solution": "public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\n    List<Interval> result = new LinkedList<>();\n    int i = 0;\n    // add all the intervals ending before newInterval starts\n    while (i < intervals.size() && intervals.get(i).end < newInterval.start)\n        result.add(intervals.get(i++));\n    // merge all overlapping intervals to one considering newInterval\n    while (i < intervals.size() && intervals.get(i).start <= newInterval.end) {\n        newInterval = new Interval( // we could mutate newInterval here also\n                Math.min(newInterval.start, intervals.get(i).start),\n                Math.max(newInterval.end, intervals.get(i).end));\n        i++;\n    }\n    result.add(newInterval); // add the union of intervals we got\n    // add all the rest\n    while (i < intervals.size()) result.add(intervals.get(i++)); \n    return result;\n}",
      "extra": "",
      "Difficulty": "Hard"
    },
    {
      "title": "Spiral Matrix II",
      "description": "Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.\nFor example,\nGiven n = 3,\nYou should return the following matrix:[\n [ 1, 2, 3 ],\n [ 8, 9, 4 ],\n [ 7, 6, 5 ]\n]",
      "example": "",
      "solution": "def generateMatrix(self, n):\n    A = [[0] * n for _ in range(n)]\n    i, j, di, dj = 0, 0, 0, 1\n    for k in xrange(n*n):\n        A[i][j] = k + 1\n        if A[(i+di)%n][(j+dj)%n]:\n            di, dj = dj, -di\n        i += di\n        j += dj\n    return A",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "Permutation Sequence",
      "description": "The set [1,2,3,â€¦,n] contains a total of n! unique permutations.\nBy listing and labeling all of the permutations in order,\nWe get the following sequence (ie, for n = 3):\n\"123\"\"132\"\"213\"\"231\"\"312\"\"321\"\n\nGiven n and k, return the kth permutation sequence.\nNote: Given n will be between 1 and 9 inclusive.",
      "example": "",
      "solution": "\"Explain-like-I'm-five\" Java Solution in O(n)\nI'm sure somewhere can be simplified so it'd be nice if anyone can let me know. The pattern was that:\nsay n = 4, you have {1, 2, 3, 4}\nIf you were to list out all the permutations you have\n1 + (permutations of 2, 3, 4)\n\n2 + (permutations of 1, 3, 4)\n\n3 + (permutations of 1, 2, 4)\n\n4 + (permutations of 1, 2, 3)\n\nWe know how to calculate the number of permutations of n numbers... n! So each of those with permutations of 3 numbers means there are 6 possible permutations. Meaning there would be a total of 24 permutations in this particular one. So if you were to look for the (k = 14) 14th permutation, it would be in the\n3 + (permutations of 1, 2, 4) subset.\nTo programmatically get that, you take k = 13 (subtract 1 because of things always starting at 0) and divide that by the 6 we got from the factorial, which would give you the index of the number you want. In the array {1, 2, 3, 4}, k/(n-1)! = 13/(4-1)! = 13/3! = 13/6 = 2. The array {1, 2, 3, 4} has a value of 3 at index 2. So the first number is a 3.\nThen the problem repeats with less numbers.\nThe permutations of {1, 2, 4} would be:\n1 + (permutations of 2, 4)\n\n2 + (permutations of 1, 4)\n\n4 + (permutations of 1, 2)\nBut our k is no longer the 14th, because in the previous step, we've already eliminated the 12 4-number permutations starting with 1 and 2. So you subtract 12 from k.. which gives you 1. Programmatically that would be...\nk = k - (index from previous) * (n-1)! = k - 2*(n-1)! = 13 - 2*(3)! = 1\nIn this second step, permutations of 2 numbers has only 2 possibilities, meaning each of the three permutations listed above a has two possibilities, giving a total of 6. We're looking for the first one, so that would be in the 1 + (permutations of 2, 4) subset.\nMeaning: index to get number from is k / (n - 2)! = 1 / (4-2)! = 1 / 2! = 0.. from {1, 2, 4}, index 0 is 1\n\nso the numbers we have so far is 3, 1... and then repeating without explanations.\n\n{2, 4}\n\nk = k - (index from pervious) * (n-2)! = k - 0 * (n - 2)! = 1 - 0 = 1;\n\nthird number's index = k / (n - 3)! = 1 / (4-3)! = 1/ 1! = 1... from {2, 4}, index 1 has 4\n\nThird number is 4\n\n{2}\n\nk = k - (index from pervious) * (n - 3)! = k - 1 * (4 - 3)! = 1 - 1 = 0;\n\nthird number's index = k / (n - 4)! = 0 / (4-4)! = 0/ 1 = 0... from {2}, index 0 has 2\n\nFourth number is 2\n\nGiving us 3142. If you manually list out the permutations using DFS method, it would be 3142. Done! It really was all about pattern finding.\npublic class Solution {\npublic String getPermutation(int n, int k) {\n    int pos = 0;\n    List<Integer> numbers = new ArrayList<>();\n    int[] factorial = new int[n+1];\n    StringBuilder sb = new StringBuilder();\n    \n    // create an array of factorial lookup\n    int sum = 1;\n    factorial[0] = 1;\n    for(int i=1; i<=n; i++){\n        sum *= i;\n        factorial[i] = sum;\n    }\n    // factorial[] = {1, 1, 2, 6, 24, ... n!}\n    \n    // create a list of numbers to get indices\n    for(int i=1; i<=n; i++){\n        numbers.add(i);\n    }\n    // numbers = {1, 2, 3, 4}\n    \n    k--;\n    \n    for(int i = 1; i <= n; i++){\n        int index = k/factorial[n-i];\n        sb.append(String.valueOf(numbers.get(index)));\n        numbers.remove(index);\n        k-=index*factorial[n-i];\n    }\n    \n    return String.valueOf(sb);\n}\n\n}",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "Rotate List",
      "description": "\nGiven a list, rotate the list to the right by k places, where k is non-negative.\nFor example:\nGiven 1->2->3->4->5->NULL and k = 2,\nreturn 4->5->1->2->3->NULL.\n",
      "example": "",
      "solution": "class Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head) return head;\n        \n        int len=1; // number of nodes\n        ListNode *newH, *tail;\n        newH=tail=head;\n        \n        while(tail->next)  // get the number of nodes in the list\n        {\n            tail = tail->next;\n            len++;\n        }\n        tail->next = head; // circle the link\n\n        if(k %= len) \n        {\n            for(auto i=0; i<len-k; i++) tail = tail->next; // the tail node is the (len-k)-th node (1st node is head)\n        }\n        newH = tail->next; \n        tail->next = NULL;\n        return newH;\n    }\n};",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "Unique Paths",
      "description": "\nA robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\nHow many possible unique paths are there?\n\nAbove is a 3 x 7 grid. How many possible unique paths are there?\nNote: m and n will be at most 100.",
      "example": "",
      "solution": "class Solution {\n    int uniquePaths(int m, int n) {\n        if (m > n) return uniquePaths(n, m);\n        vector<int> cur(m, 1);\n        for (int j = 1; j < n; j++)\n            for (int i = 1; i < m; i++)\n                cur[i] += cur[i - 1]; \n        return cur[m - 1];\n    }\n}; ",
      "extra": "https://leetcode.com/static/images/problemset/robot_maze.png",
      "Difficulty": "Medium"
    },
    {
      "title": "Unique Paths II",
      "description": "Follow up for \"Unique Paths\":\nNow consider if some obstacles are added to the grids. How many unique paths would there be?\nAn obstacle and empty space is marked as 1 and 0 respectively in the grid.\nFor example,\nThere is one obstacle in the middle of a 3x3 grid as illustrated below.\n[\n  [0,0,0],\n  [0,1,0],\n  [0,0,0]\n]\n\nThe total number of unique paths is 2.\nNote: m and n will be at most 100.",
      "example": "",
      "solution": "public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n    int width = obstacleGrid[0].length;\n    int[] dp = new int[width];\n    dp[0] = 1;\n    for (int[] row : obstacleGrid) {\n        for (int j = 0; j < width; j++) {\n            if (row[j] == 1)\n                dp[j] = 0;\n            else if (j > 0)\n                dp[j] += dp[j - 1];\n        }\n    }\n    return dp[width - 1];\n}",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "Minimum Path Sum",
      "description": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\n",
      "example": "",
      "solution": "class Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n        vector<int> cur(m, grid[0][0]);\n        for (int i = 1; i < m; i++)\n            cur[i] = cur[i - 1] + grid[i][0]; \n        for (int j = 1; j < n; j++) {\n            cur[0] += grid[0][j]; \n            for (int i = 1; i < m; i++)\n                cur[i] = min(cur[i - 1], cur[i]) + grid[i][j];\n        }\n        return cur[m - 1];\n    }\n};",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "Add Binary",
      "description": "Given two binary strings, return their sum (also a binary string).\nFor example,\na = \"11\"\nb = \"1\"\nReturn \"100\".",
      "example": "",
      "solution": "class Solution\n{\npublic:\n    string addBinary(string a, string b)\n    {\n        string s = \"\";\n        \n        int c = 0, i = a.size() - 1, j = b.size() - 1;\n        while(i >= 0 || j >= 0 || c == 1)\n        {\n            c += i >= 0 ? a[i --] - '0' : 0;\n            c += j >= 0 ? b[j --] - '0' : 0;\n            s = char(c % 2 + '0') + s;\n            c /= 2;\n        }\n        \n        return s;\n    }\n};",
      "extra": "",
      "Difficulty": "Easy"
    },
    {
      "title": "Text Justification",
      "description": "Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly L characters.\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\nFor the last line of text, it should be left justified and no extra space is inserted between words.\nFor example,\nwords: [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\nL: 16.\nReturn the formatted lines as:\n[\n   \"This    is    an\",\n   \"example  of text\",\n   \"justification.  \"\n]\n\n\nNote: Each word is guaranteed not to exceed L in length.",
      "example": "",
      "solution": "vector<string> fullJustify(vector<string> &words, int L) {\n    vector<string> res;\n    for(int i = 0, k, l; i < words.size(); i += k) {\n        for(k = l = 0; i + k < words.size() and l + words[i+k].size() <= L - k; k++) {\n            l += words[i+k].size();\n        }\n        string tmp = words[i];\n        for(int j = 0; j < k - 1; j++) {\n            if(i + k >= words.size()) tmp += \" \";\n            else tmp += string((L - l) / (k - 1) + (j < (L - l) % (k - 1)), ' ');\n            tmp += words[i+j+1];\n        }\n        tmp += string(L - tmp.size(), ' ');\n        res.push_back(tmp);\n    }\n    return res;\n}",
      "extra": "",
      "Difficulty": "Hard"
    },
    {
      "title": "Set Matrix Zeroes",
      "description": "Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.\nclick to show follow up.\nFollow up:\n\nA straight forward solution using O(mn) space is probably a bad idea.\nA simple improvement uses O(m + n) space, but still not the best solution.\nCould you devise a constant space solution?",
      "example": "",
      "solution": "void setZeroes(vector<vector<int> > &matrix) {\n    int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\n\n    for (int i = 0; i < rows; i++) {\n        if (matrix[i][0] == 0) col0 = 0;\n        for (int j = 1; j < cols; j++)\n            if (matrix[i][j] == 0)\n                matrix[i][0] = matrix[0][j] = 0;\n    }\n\n    for (int i = rows - 1; i >= 0; i--) {\n        for (int j = cols - 1; j >= 1; j--)\n            if (matrix[i][0] == 0 || matrix[0][j] == 0)\n                matrix[i][j] = 0;\n        if (col0 == 0) matrix[i][0] = 0;\n    }\n}",
      "extra": "",
      "Difficulty": "Medium"
    },
    {
      "title": "Edit Distance",
      "description": "Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)\nYou have the following 3 operations permitted on a word:\na) Insert a character\nb) Delete a character\nc) Replace a character",
      "example": "",
      "solution": "This is a classic problem of Dynamic Programming. We define the state dp[i][j] to be the minimum number of operations to convert word1[0..i - 1] to word2[0..j - 1]. The state equations have two cases: the boundary case and the general case. Note that in the above notations, both i and j take values starting from 1.\nFor the boundary case, that is, to convert a string to an empty string, it is easy to see that the mininum number of operations to convert word1[0..i - 1] to \"\" requires at least i operations (deletions). In fact, the boundary case is simply:\ndp[i][0] = i;dp[0][j] = j.\nNow let's move on to the general case, that is, convert a non-empty word1[0..i - 1] to another non-empty word2[0..j - 1]. Well, let's try to break this problem down into smaller problems (sub-problems). Suppose we have already known how to convert word1[0..i - 2] to word2[0..j - 2], which is dp[i - 1][j - 1]. Now let's consider word[i - 1] and word2[j - 1]. If they are euqal, then no more operation is needed and dp[i][j] = dp[i - 1][j - 1]. Well, what if they are not equal?\nIf they are not equal, we need to consider three cases:\nReplace word1[i - 1] by word2[j - 1] (dp[i][j] = dp[i - 1][j - 1] + 1 (for replacement));Delete word1[i - 1] and word1[0..i - 2] = word2[0..j - 1] (dp[i][j] = dp[i - 1][j] + 1 (for deletion));Insert word2[j - 1] to word1[0..i - 1] and word1[0..i - 1] + word2[j - 1] = word2[0..j - 1] (dp[i][j] = dp[i][j - 1] + 1 (for insertion)).\nMake sure you understand the subtle differences between the equations for deletion and insertion. For deletion, we are actually converting word1[0..i - 2] to word2[0..j - 1], which costs dp[i - 1][j], and then deleting the word1[i - 1], which costs 1. The case is similar for insertion.\nPutting these together, we now have:\ndp[i][0] = i;dp[0][j] = j;dp[i][j] = dp[i - 1][j - 1], if word1[i - 1] = word2[j - 1];dp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i][j - 1] + 1), otherwise.\nThe above state equations can be turned into the following code directly.\nclass Solution { \npublic:\n    int minDistance(string word1, string word2) { \n        int m = word1.length(), n = word2.length();\n        vector<vector<int> > dp(m + 1, vector<int> (n + 1, 0));\n        for (int i = 1; i <= m; i++)\n            dp[i][0] = i;\n        for (int j = 1; j <= n; j++)\n            dp[0][j] = j;  \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (word1[i - 1] == word2[j - 1]) \n                    dp[i][j] = dp[i - 1][j - 1];\n                else dp[i][j] = min(dp[i - 1][j - 1] + 1, min(dp[i][j - 1] + 1, dp[i - 1][j] + 1));\n            }\n        }\n        return dp[m][n];\n    }\n};\n\nWell, you may have noticed that each time when we update dp[i][j], we only need dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]. In fact, we need not maintain the full m*n matrix. Instead, maintaing one column is enough. The code can be optimized to O(m) or O(n) space, depending on whether you maintain a row or a column of the original matrix.\nThe optimized code is as follows.\nclass Solution { \npublic:\n    int minDistance(string word1, string word2) {\n        int m = word1.length(), n = word2.length();\n        vector<int> cur(m + 1, 0);\n        for (int i = 1; i <= m; i++)\n            cur[i] = i;\n        for (int j = 1; j <= n; j++) {\n            int pre = cur[0];\n            cur[0] = j;\n            for (int i = 1; i <= m; i++) {\n                int temp = cur[i];\n                if (word1[i - 1] == word2[j - 1])\n                    cur[i] = pre;\n                else cur[i] = min(pre + 1, min(cur[i] + 1, cur[i - 1] + 1));\n                pre = temp;\n            }\n        }\n        return cur[m]; \n    }\n}; \n\nWell, if you find the above code hard to understand, you may first try to write a two-column version that explicitly maintains two columns (the previous column and the current column) and then simplify the two-column version into the one-column version like the above code :-)",
      "extra": "",
      "Difficulty": "Hard"
    },
    {
      "title": "Counting Bits",
      "description": "Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.\nExample:\nFor num = 5 you should return [0,1,1,2,1,2].\nFollow up:\nIt is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?Space complexity should be O(n).Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.",
      "example": "",
      "solution": "An easy recurrence for this problem is f[i] = f[i / 2] + i % 2.\npublic int[] countBits(int num) {\n    int[] f = new int[num + 1];\n    for (int i=1; i<=num; i++) f[i] = f[i >> 1] + (i & 1);\n    return f;\n}",
      "extra": "",
      "Difficulty": "Medium"
    }
  ]
}